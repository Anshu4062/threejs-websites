var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// ../../node_modules/.pnpm/tsup@8.0.2_postcss@8.4.38_typescript@5.4.5/node_modules/tsup/assets/esm_shims.js
var init_esm_shims = __esm({
  "../../node_modules/.pnpm/tsup@8.0.2_postcss@8.4.38_typescript@5.4.5/node_modules/tsup/assets/esm_shims.js"() {
    "use strict";
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isObject.js
var require_isObject = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isObject.js"(exports, module) {
    "use strict";
    init_esm_shims();
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    module.exports = isObject;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_freeGlobal.js
var require_freeGlobal = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_freeGlobal.js"(exports, module) {
    "use strict";
    init_esm_shims();
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    module.exports = freeGlobal;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_root.js
var require_root = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_root.js"(exports, module) {
    "use strict";
    init_esm_shims();
    var freeGlobal = require_freeGlobal();
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    module.exports = root;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/now.js
var require_now = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/now.js"(exports, module) {
    "use strict";
    init_esm_shims();
    var root = require_root();
    var now = function() {
      return root.Date.now();
    };
    module.exports = now;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_trimmedEndIndex.js
var require_trimmedEndIndex = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_trimmedEndIndex.js"(exports, module) {
    "use strict";
    init_esm_shims();
    var reWhitespace = /\s/;
    function trimmedEndIndex(string) {
      var index = string.length;
      while (index-- && reWhitespace.test(string.charAt(index))) {
      }
      return index;
    }
    module.exports = trimmedEndIndex;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseTrim.js
var require_baseTrim = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseTrim.js"(exports, module) {
    "use strict";
    init_esm_shims();
    var trimmedEndIndex = require_trimmedEndIndex();
    var reTrimStart = /^\s+/;
    function baseTrim(string) {
      return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
    }
    module.exports = baseTrim;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Symbol.js
var require_Symbol = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Symbol.js"(exports, module) {
    "use strict";
    init_esm_shims();
    var root = require_root();
    var Symbol2 = root.Symbol;
    module.exports = Symbol2;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getRawTag.js
var require_getRawTag = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getRawTag.js"(exports, module) {
    "use strict";
    init_esm_shims();
    var Symbol2 = require_Symbol();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var nativeObjectToString = objectProto.toString;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    module.exports = getRawTag;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_objectToString.js
var require_objectToString = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_objectToString.js"(exports, module) {
    "use strict";
    init_esm_shims();
    var objectProto = Object.prototype;
    var nativeObjectToString = objectProto.toString;
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    module.exports = objectToString;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseGetTag.js
var require_baseGetTag = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseGetTag.js"(exports, module) {
    "use strict";
    init_esm_shims();
    var Symbol2 = require_Symbol();
    var getRawTag = require_getRawTag();
    var objectToString = require_objectToString();
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    module.exports = baseGetTag;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isObjectLike.js"(exports, module) {
    "use strict";
    init_esm_shims();
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    module.exports = isObjectLike;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isSymbol.js
var require_isSymbol = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isSymbol.js"(exports, module) {
    "use strict";
    init_esm_shims();
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var symbolTag = "[object Symbol]";
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
    }
    module.exports = isSymbol;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/toNumber.js
var require_toNumber = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/toNumber.js"(exports, module) {
    "use strict";
    init_esm_shims();
    var baseTrim = require_baseTrim();
    var isObject = require_isObject();
    var isSymbol = require_isSymbol();
    var NAN = 0 / 0;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = baseTrim(value);
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module.exports = toNumber;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/debounce.js
var require_debounce = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/debounce.js"(exports, module) {
    "use strict";
    init_esm_shims();
    var isObject = require_isObject();
    var now = require_now();
    var toNumber = require_toNumber();
    var FUNC_ERROR_TEXT = "Expected a function";
    var nativeMax = Math.max;
    var nativeMin = Math.min;
    function debounce3(func, wait, options) {
      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = "maxWait" in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      function invokeFunc(time) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }
      function leadingEdge(time) {
        lastInvokeTime = time;
        timerId = setTimeout(timerExpired, wait);
        return leading ? invokeFunc(time) : result;
      }
      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
        return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
      }
      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
      }
      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        timerId = setTimeout(timerExpired, remainingWait(time));
      }
      function trailingEdge(time) {
        timerId = void 0;
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = void 0;
        return result;
      }
      function cancel() {
        if (timerId !== void 0) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
      }
      function flush() {
        return timerId === void 0 ? result : trailingEdge(now());
      }
      function debounced() {
        var time = now(), isInvoking = shouldInvoke(time);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
          if (timerId === void 0) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            clearTimeout(timerId);
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === void 0) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }
    module.exports = debounce3;
  }
});

// compiler/index.ts
init_esm_shims();

// compiler/vite.ts
init_esm_shims();

// compiler/src/index.ts
init_esm_shims();
import path3 from "path";
import { createUnplugin } from "unplugin";
import { createFilter } from "@rollup/pluginutils";

// compiler/src/core/bridge.ts
init_esm_shims();
import { normalize } from "pathe";

// compiler/src/axiom.ts
init_esm_shims();
import { Axiom } from "@axiomhq/js";

// compiler/src/core/utils/machine-id.ts
init_esm_shims();
import os from "os";
import path from "path";
import fs from "fs";
import { randomUUID } from "crypto";
var getConfigDir = (name) => {
  const homedir = os.homedir();
  const macos = () => path.join(homedir, "Library", "Preferences", name);
  const win = () => {
    const { APPDATA = path.join(homedir, "AppData", "Roaming") } = process.env;
    return path.join(APPDATA, name, "Config");
  };
  const linux = () => {
    const { XDG_CONFIG_HOME = path.join(homedir, ".config") } = process.env;
    return path.join(XDG_CONFIG_HOME, name);
  };
  switch (process.platform) {
    case "darwin":
      return macos();
    case "win32":
      return win();
    default:
      return linux();
  }
};
var configDir = getConfigDir("million-lint");
var machineId = randomUUID();
var getMachineIdAsync = async () => {
  if (!machineId) {
    try {
      const stat = fs.statSync(path.join(configDir, "machineId.txt"));
      if (stat.isFile()) {
        machineId = fs.readFileSync(path.join(configDir, "machineId.txt"), "utf8") || machineId;
      }
    } catch (err) {
      if (err instanceof Error) {
        void saveLog("error", {
          origin: "Failed to read machine-id",
          message: err.message,
          stack: err.stack,
          configDir
        });
      }
    }
  }
  return machineId;
};
var getMachineId = () => {
  return machineId;
};

// compiler/src/axiom.ts
var axiom = new Axiom({
  token: "xaat-137e6732-9a45-48d9-b12c-964c9fa88ed3"
});
var trunc = (str, length) => {
  if (str.length <= length)
    return str;
  return `${str.slice(0, length)}...`;
};
var saveLog = async (level, message) => {
  const machineId2 = await getMachineIdAsync();
  for (const key in message) {
    if (typeof message[key] === "string") {
      message[key] = trunc(message[key], 2 ** 14);
    }
  }
  try {
    axiom.ingest("compiler", {
      level,
      machineId: machineId2,
      message: JSON.stringify(
        // eslint-disable-next-line prefer-object-spread
        Object.assign({}, message, {
          NODE_ENV: process.env.NODE_ENV
        })
      )
    });
  } catch (_err) {
  }
};

// compiler/src/core/utils/log.ts
init_esm_shims();

// ../../node_modules/.pnpm/kleur@4.1.5/node_modules/kleur/colors.mjs
init_esm_shims();
var FORCE_COLOR;
var NODE_DISABLE_COLORS;
var NO_COLOR;
var TERM;
var isTTY = true;
if (typeof process !== "undefined") {
  ({ FORCE_COLOR, NODE_DISABLE_COLORS, NO_COLOR, TERM } = process.env || {});
  isTTY = process.stdout && process.stdout.isTTY;
}
var $ = {
  enabled: !NODE_DISABLE_COLORS && NO_COLOR == null && TERM !== "dumb" && (FORCE_COLOR != null && FORCE_COLOR !== "0" || isTTY)
};
function init(x, y) {
  let rgx = new RegExp(`\\x1b\\[${y}m`, "g");
  let open = `\x1B[${x}m`, close = `\x1B[${y}m`;
  return function(txt) {
    if (!$.enabled || txt == null)
      return txt;
    return open + (!!~("" + txt).indexOf(close) ? txt.replace(rgx, close + open) : txt) + close;
  };
}
var reset = init(0, 0);
var bold = init(1, 22);
var dim = init(2, 22);
var italic = init(3, 23);
var underline = init(4, 24);
var inverse = init(7, 27);
var hidden = init(8, 28);
var strikethrough = init(9, 29);
var black = init(30, 39);
var red = init(31, 39);
var green = init(32, 39);
var yellow = init(33, 39);
var blue = init(34, 39);
var magenta = init(35, 39);
var cyan = init(36, 39);
var white = init(37, 39);
var gray = init(90, 39);
var grey = init(90, 39);
var bgBlack = init(40, 49);
var bgRed = init(41, 49);
var bgGreen = init(42, 49);
var bgYellow = init(43, 49);
var bgBlue = init(44, 49);
var bgMagenta = init(45, 49);
var bgCyan = init(46, 49);
var bgWhite = init(47, 49);

// compiler/src/core/utils/log.ts
var isDisplayed = false;
var createSessionBlock = (sessionId) => {
  const title = "Join session ";
  const width = sessionId.length;
  return `

 ${magenta("\u25C7")}  ${title}${dim("\u2500".repeat(width - title.length))}${dim("\u2500\u2500\u256E")}
 ${dim("\u2502")}  ${" ".repeat(width)}  ${dim("\u2502")}
 ${dim("\u2502")}  ${cyan(sessionId)}  ${dim("\u2502")}
 ${dim("\u2502")}  ${" ".repeat(width)}  ${dim("\u2502")}
 ${dim("\u2514\u2500\u2500")}${dim("\u2500".repeat(width))}${dim("\u2500\u2500\u256F")}
`;
};
var displayIntro = (port, sessionId) => {
  if (isDisplayed)
    return;
  const initialTime = performance.now();
  isDisplayed = true;
  console.log(
    `
 ${bold(magenta(`\u26A1 Million Lint v${"1.0.0-rc.26"}`))}
 - Ingest server: ${port ? cyan(`http://localhost:${port}`) : "failed to start"}${sessionId ? createSessionBlock(sessionId) : ""}
`
  );
  console.log(
    ` ${green("\u2713")} Ready in ${(performance.now() - initialTime).toFixed(2)}ms`
  );
};
var moduleCount = 0;
var cumulativeTime = 0;
var numberOfTimes = 0;
var prettyMs = (time) => {
  return `${time.toFixed(0)}ms`;
};
void (async () => {
  prettyMs = (await import("pretty-ms")).default;
})();
var logStart = (filename) => {
  console.log(` ${gray("\u25CB")} ${filename} \u2026`);
  return performance.now();
};
var logEnd = (filename, initialTime, stats) => {
  if (initialTime === null)
    return 0;
  const diff = performance.now() - initialTime;
  let color = white;
  const average = cumulativeTime / numberOfTimes;
  if (average !== 0) {
    if (average * 3 < diff) {
      color = magenta;
    } else if (average * 2 < diff) {
      color = red;
    } else if (average * 1.5 < diff) {
      color = yellow;
    }
  }
  cumulativeTime += diff;
  numberOfTimes++;
  moduleCount++;
  console.log(` ${green("\u2714")} ${filename} in ${color(prettyMs(diff))}`);
  if ((stats == null ? void 0 : stats.components) && (stats == null ? void 0 : stats.captures)) {
    console.log(gray(`  - ${stats.components} components`));
    console.log(gray(`  - ${stats.captures} captures`));
  }
  return diff;
};
var logFinish = (totalTime, stats) => {
  if (totalTime === 0)
    return;
  console.log(
    ` ${magenta("\u2726")} Completed in ${prettyMs(totalTime)} (${moduleCount} modules)`
  );
  void saveLog("log", {
    origin: "Completed compile",
    moduleCount,
    totalTime,
    ...stats
  });
};
var logError = (message) => {
  console.error(` ${yellow("\u26A0")} ${message}`);
};

// compiler/src/core/bridge.ts
var ENDPOINT = "https://million-lint-git-feat-proxy-millionjs.vercel.app/api/v1/ingest";
var DEFAULT_PORT = 52921;
var isSameCwd = (thisCwd, otherCwd = "") => {
  thisCwd = normalize(thisCwd);
  otherCwd = normalize(otherCwd);
  return thisCwd === otherCwd || thisCwd.includes(otherCwd) || otherCwd.includes(thisCwd);
};
async function* getPossibleConnections(port = DEFAULT_PORT) {
  for (const host of ["localhost", "0.0.0.0"]) {
    const promises = [];
    for (let i = 0; i < 10; i++) {
      promises.push(
        fetch(`http://${host}:${port + i}/this`).then(async (response) => {
          if (!response.ok)
            return void 0;
          const windows2 = await response.json();
          return windows2;
        }).catch(() => void 0)
      );
    }
    const windows = await Promise.all(promises);
    for (const window of windows.flat()) {
      if (!window)
        continue;
      yield {
        id: window.id,
        host,
        port: window.port,
        vscode_cwd: window.cwd,
        cwd: process.cwd(),
        match: isSameCwd(process.cwd(), window.cwd),
        normalized: {
          v: normalize(window.cwd),
          p: normalize(process.cwd())
        }
      };
    }
  }
}
async function* getSessions(port = DEFAULT_PORT) {
  const sessions = /* @__PURE__ */ new Set();
  for await (const connection of getPossibleConnections(port)) {
    if (!connection)
      return;
    if (connection.match && !sessions.has(connection.id)) {
      sessions.add(connection.id);
      yield {
        host: connection.host,
        port: connection.port
      };
    }
  }
}
var reset2 = async () => {
  if (store.sessionId) {
    await fetch(`${store.proxyUrl}/reset`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "X-Session-Id": store.sessionId
      }
    }).catch((err) => {
      void saveLog("error", {
        origin: "Failed to reset data",
        message: err.message,
        stack: err.stack
      });
    });
  } else {
    const ports = [];
    try {
      for await (const { port, host } of getSessions()) {
        void fetch(`http://${host}:${port}/reset`).catch(() => null);
        ports.push(port);
      }
    } catch (err) {
      if (err instanceof Error) {
        void saveLog("error", {
          origin: "Failed to reset data",
          message: err.message,
          stack: err.stack,
          ports
        });
      }
    }
  }
};
var report = async (payload) => {
  payload.cwd = process.cwd();
  if (store.sessionId) {
    await fetch(`${store.proxyUrl}/compiler`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "X-Session-Id": store.sessionId
      },
      body: JSON.stringify(payload.compiler)
    }).catch((err) => {
      console.error(err);
      void saveLog("error", {
        origin: "Failed to send compiler data to proxy server",
        message: err.message,
        stack: err.stack
      });
    });
  } else {
    const ports = [];
    try {
      if (process.env.NODE_ENV === "production") {
        void fetch(ENDPOINT, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        }).catch((err) => {
          void saveLog("error", {
            origin: "Failed to send data to ingest server",
            message: err.message,
            stack: err.stack,
            ports
          });
        });
      } else {
        for await (const { port, host } of getSessions()) {
          void fetch(`http://${host}:${port}/ingest`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload)
          }).catch((err) => {
            void saveLog("error", {
              origin: "Failed to send data to ingest server",
              message: err.message,
              stack: err.stack,
              ports
            });
          });
          ports.push(port);
        }
      }
    } catch (err) {
      logError(
        "Failed to send data to ingest server, please restart your dev server."
      );
      if (err instanceof Error) {
        void saveLog("error", {
          origin: "Failed to send data to ingest server",
          message: err.message,
          stack: err.stack,
          ports
        });
      }
    }
  }
};

// compiler/src/core/compile.ts
init_esm_shims();
import { transformAsync } from "@babel/core";
import hermesParser from "babel-plugin-syntax-hermes-parser";

// compiler/src/core/plugin.ts
init_esm_shims();
import * as t10 from "@babel/types";

// compiler/src/core/capture/metadata.ts
init_esm_shims();
import * as t7 from "@babel/types";

// compiler/src/core/constants.ts
init_esm_shims();
var ANYA_IGNORE = "million/lint ignore";
var RUNTIME_SOURCE = `${"@million/lint/runtime"}${process.env.NODE_ENV === "production" ? "" : "-dev"}`;
var ANYA_CAPTURE = {
  kind: "named",
  name: "$$",
  source: RUNTIME_SOURCE
};
var ANYA_REGISTER_METADATA = {
  kind: "named",
  name: "registerMetadata",
  source: RUNTIME_SOURCE
};
var BANNED_COMPONENTS = [
  "Route",
  "Routes",
  "Switch",
  "Redirect",
  "Navigate",
  "Outlet",
  "Suspense",
  "ScrollRestoration",
  "Fragment",
  "Link",
  "Layout"
];

// compiler/src/core/utils/get-descriptive-name.ts
init_esm_shims();
import * as t2 from "@babel/types";

// compiler/src/core/utils/checks.ts
init_esm_shims();
import * as t from "@babel/types";
var getImportSpecifierName = (specifier) => {
  if (t.isIdentifier(specifier.imported)) {
    return specifier.imported.name;
  }
  return specifier.imported.value;
};
var isComponent = (node) => {
  switch (node.type) {
    case "ArrowFunctionExpression":
    case "FunctionExpression":
    case "FunctionDeclaration":
      return true;
    default:
      return false;
  }
};
var isCapitalized = (str) => {
  return Boolean(str.length) && str[0] >= "A" && str[0] <= "Z";
};
var isHookName = (ctx, id) => {
  return Boolean(ctx.filters.hook) && ctx.filters.hook.test(id.name);
};
var hasJSX = (path4) => {
  let jsx = false;
  path4.traverse({
    JSXElement(childPath) {
      jsx = true;
      childPath.stop();
    },
    JSXFragment(childPath) {
      jsx = true;
      childPath.stop();
    }
  });
  return jsx;
};
var getComponentType = (ctx, path4) => {
  if (!path4)
    return void 0;
  if (path4.node.type === "ArrowFunctionExpression") {
    return "function";
  }
  if (!path4.node.id) {
    return void 0;
  }
  return getTypeFromComponentName(ctx, path4, path4.node.id);
};
var getTypeFromComponentName = (ctx, path4, id) => {
  if (ctx.filters.component.test(id.name)) {
    return hasJSX(path4) ? "component" : "function";
  }
  if (isHookName(ctx, id)) {
    return "hook";
  }
  if (hasJSX(path4)) {
    return "function";
  }
  return void 0;
};
var isPathValid = (path4, key) => {
  return key(path4.node);
};
var isNestedExpression = (node) => {
  switch (node.type) {
    case "ParenthesizedExpression":
    case "TypeCastExpression":
    case "TSAsExpression":
    case "TSSatisfiesExpression":
    case "TSNonNullExpression":
    case "TSTypeAssertion":
    case "TSInstantiationExpression":
      return true;
    default:
      return false;
  }
};

// compiler/src/core/utils/get-descriptive-name.ts
var getDescriptiveNamePath = (path4) => {
  let current = path4;
  while (current) {
    switch (current.node.type) {
      case "FunctionDeclaration":
      case "FunctionExpression": {
        const id = current.get("id");
        if (isPathValid(id, t2.isIdentifier))
          return id;
        break;
      }
      case "VariableDeclarator": {
        const id = current.get("id");
        return isPathValid(id, t2.isIdentifier) ? id : void 0;
      }
      case "ClassPrivateMethod":
      case "ClassMethod":
      case "ObjectMethod": {
        const key = current.get("key");
        if (isPathValid(key, t2.isIdentifier)) {
          return key;
        }
        if (isPathValid(key, t2.isPrivateName)) {
          return key.get("id");
        }
        return void 0;
      }
      default:
        break;
    }
    current = current.parentPath;
  }
  return void 0;
};
var getDescriptiveName = (path4, defaultName) => {
  let current = path4;
  while (current) {
    switch (current.node.type) {
      case "FunctionDeclaration":
      case "FunctionExpression": {
        if (t2.isIdentifier(current.node.id)) {
          return current.node.id.name;
        }
        break;
      }
      case "VariableDeclarator":
        return t2.isIdentifier(current.node.id) ? current.node.id.name : defaultName;
      case "ClassPrivateMethod":
      case "ClassMethod":
      case "ObjectMethod": {
        switch (current.node.key.type) {
          case "Identifier":
            return current.node.key.name;
          case "PrivateName":
            return current.node.key.id.name;
          default:
            return defaultName;
        }
      }
      default:
        break;
    }
    current = current.parentPath;
  }
  return defaultName;
};

// compiler/src/core/utils/get-import-identifier.ts
init_esm_shims();
import * as t4 from "@babel/types";

// compiler/src/core/utils/generate-unique-name.ts
init_esm_shims();
import * as t3 from "@babel/types";
var generateUniqueName = (path4, name) => {
  let uid;
  let i = 1;
  do {
    uid = `${name}_${i}`;
    i++;
  } while (path4.scope.hasLabel(uid) || path4.scope.hasBinding(uid) || path4.scope.hasGlobal(uid) || path4.scope.hasReference(uid));
  const program = path4.scope.getProgramParent();
  program.references[uid] = true;
  program.uids[uid] = true;
  return t3.identifier(uid);
};

// compiler/src/core/utils/get-import-identifier.ts
var getImportIdentifier = (ctx, path4, registration) => {
  const name = registration.kind === "named" ? registration.name : "default";
  const target = `${registration.source}[${name}]`;
  const current = ctx.imports.get(target);
  if (current) {
    return current;
  }
  const programParent = path4.scope.getProgramParent();
  const uid = generateUniqueName(programParent.path, name);
  programParent.registerDeclaration(
    programParent.path.unshiftContainer(
      "body",
      t4.importDeclaration(
        [
          registration.kind === "named" ? t4.importSpecifier(uid, t4.identifier(registration.name)) : t4.importDefaultSpecifier(uid)
        ],
        t4.stringLiteral(registration.source)
      )
    )[0]
  );
  ctx.imports.set(target, uid);
  return uid;
};

// compiler/src/core/utils/unwrap.ts
init_esm_shims();
import * as t5 from "@babel/types";
var unwrapNode = (node, key) => {
  if (key(node)) {
    return node;
  }
  if (isNestedExpression(node)) {
    return unwrapNode(node.expression, key);
  }
  return void 0;
};
var unwrapPath = (path4, key) => {
  if (isPathValid(path4, key)) {
    return path4;
  }
  if (isPathValid(path4, isNestedExpression)) {
    return unwrapPath(path4.get("expression"), key);
  }
  return void 0;
};
var unwrapBody = (path4) => {
  if (path4.isFunctionDeclaration() || path4.isFunctionExpression() || path4.isArrowFunctionExpression() || path4.isProgram()) {
    if (Array.isArray(path4.node.body)) {
      return path4.node.body;
    }
    if (t5.isBlockStatement(path4.node.body)) {
      return path4.node.body.body;
    }
  }
  return null;
};
var unwrapLoc = (loc) => {
  return [
    (loc == null ? void 0 : loc.start.line) ?? 0,
    (loc == null ? void 0 : loc.start.column) ?? 0,
    (loc == null ? void 0 : loc.end.line) ?? 0,
    (loc == null ? void 0 : loc.end.column) ?? 0
  ];
};

// compiler/src/core/utils/wrap-hmr.ts
init_esm_shims();
import * as t6 from "@babel/types";
var importMetaHot = t6.memberExpression(
  t6.memberExpression(t6.identifier("import"), t6.identifier("meta")),
  t6.identifier("hot")
);
var importMetaWebpackHot = t6.memberExpression(
  t6.memberExpression(t6.identifier("import"), t6.identifier("meta")),
  t6.identifier("webpackHot")
);
var moduleHotAccept = t6.memberExpression(
  t6.identifier("module"),
  t6.identifier("hot")
);
var isCJS = t6.binaryExpression(
  "===",
  t6.unaryExpression("typeof", t6.identifier("module")),
  t6.stringLiteral("undefined")
);
var wrapHMR = (ctx, path4, expression) => {
  const reset3 = getImportIdentifier(ctx, path4, {
    kind: "named",
    name: "reset",
    source: RUNTIME_SOURCE
  });
  const init3 = getImportIdentifier(ctx, path4, {
    kind: "named",
    name: "init",
    source: RUNTIME_SOURCE
  });
  const importHot = ctx.options.framework === "webpack" ? importMetaWebpackHot : importMetaHot;
  const statements = [];
  statements.push(t6.expressionStatement(t6.callExpression(reset3, [])));
  const ingest = ctx.options.ingest;
  const url = store.proxyUrl ? `${store.proxyUrl}/ingest` : ctx.options.runtimeURL || // Use runtime url if available
  `http://${(ingest == null ? void 0 : ingest.host) || "localhost"}:${store.port}/ingest`;
  statements.push(
    t6.expressionStatement(
      t6.callExpression(init3, [
        t6.objectExpression([
          t6.objectProperty(t6.identifier("url"), t6.stringLiteral(url)),
          t6.objectProperty(t6.identifier("id"), t6.stringLiteral(getMachineId())),
          t6.objectProperty(
            t6.identifier("apiKey"),
            t6.stringLiteral(
              process.env.NODE_ENV === "production" ? ctx.options.apiKey || "" : "dev"
            )
          ),
          t6.objectProperty(
            t6.identifier("sessionId"),
            store.sessionId ? t6.stringLiteral(store.sessionId) : t6.nullLiteral()
          )
        ])
      ])
    )
  );
  statements.push(t6.expressionStatement(expression));
  const callbackId = path4.scope.generateUidIdentifier("c");
  const callback = t6.variableDeclaration("let", [
    t6.variableDeclarator(
      callbackId,
      t6.arrowFunctionExpression([], t6.blockStatement(statements))
    )
  ]);
  const acceptCallback = t6.arrowFunctionExpression(
    [],
    t6.blockStatement([t6.expressionStatement(t6.callExpression(callbackId, []))])
  );
  const legacyHmr = t6.ifStatement(
    moduleHotAccept,
    t6.blockStatement([
      t6.expressionStatement(
        t6.callExpression(
          t6.memberExpression(moduleHotAccept, t6.identifier("accept")),
          [t6.stringLiteral(ctx.options.absoluteFilename), acceptCallback]
        )
      )
    ])
  );
  const hmr = ctx.options.legacyHmr ? legacyHmr : t6.ifStatement(
    isCJS,
    t6.blockStatement([
      t6.ifStatement(
        importHot,
        t6.blockStatement([
          t6.expressionStatement(
            t6.callExpression(
              t6.memberExpression(importHot, t6.identifier("accept")),
              [
                t6.stringLiteral(ctx.options.absoluteFilename),
                acceptCallback
              ]
            )
          )
        ])
      )
    ]),
    legacyHmr
  );
  return [
    callback,
    t6.tryStatement(
      t6.blockStatement([hmr]),
      t6.catchClause(t6.identifier("_"), t6.blockStatement([]))
    ),
    t6.expressionStatement(t6.callExpression(callbackId, []))
  ];
};

// compiler/src/core/capture/metadata.ts
var JSX_RE = /<(?<temp1>"[^"]*"|'[^']*'|[^'">])*>/;
var hasJSX2 = (path4) => {
  if (JSX_RE.test(path4.getSource()))
    return true;
  let hasJSX3 = false;
  path4.traverse({
    JSXElement(path5) {
      hasJSX3 = true;
      path5.stop();
    },
    JSXFragment(path5) {
      hasJSX3 = true;
      path5.stop();
    }
  });
  return hasJSX3;
};
var cache = /* @__PURE__ */ new Map();
var getExternals = (path4, componentName) => {
  const externals = {};
  const bindings = path4.scope.getAllBindings();
  for (const bindingName in bindings) {
    const bindingValue = bindings[bindingName];
    const key = `${bindingName}.${bindingValue.scope.uid}`;
    if (bindingValue && bindingName === componentName)
      continue;
    if (bindingValue.scope.uid === path4.scope.uid) {
      continue;
    }
    if (cache.has(key)) {
      externals[bindingName] = cache.get(key);
      continue;
    }
    const kind = bindingValue.kind;
    const loc = unwrapLoc(bindingValue.path.node.loc);
    if (bindingName === "arguments" || kind === "param")
      continue;
    externals[bindingName] = {
      kind,
      loc,
      jsx: hasJSX2(bindingValue.path)
    };
    cache.set(key, externals[bindingName]);
  }
  return externals;
};
var registerMetadata = (ctx, path4, key, index, componentName, checkScope = true) => {
  var _a;
  const registerMetadata2 = getImportIdentifier(
    ctx,
    path4,
    ANYA_REGISTER_METADATA
  );
  const scope = path4.scope.getBlockParent().parent;
  if (checkScope && (!scope || ![
    "Program",
    "BlockStatement",
    "FunctionDeclaration",
    "FunctionExpression"
  ].includes(scope.path.type))) {
    return;
  }
  if (!t7.isArrowFunctionExpression(path4.node) && t7.isIdentifier(path4.node.id) && !(scope == null ? void 0 : scope.path.scope.hasBinding(path4.node.id.name))) {
    return;
  }
  ctx.queue.push(() => {
    const register = t7.callExpression(registerMetadata2, [
      t7.stringLiteral(key),
      t7.numericLiteral(index),
      t7.identifier(componentName)
    ]);
    const body = unwrapBody(checkScope ? scope.path : path4);
    if (!body)
      return;
    if (process.env.NODE_ENV === "production") {
      body.push(t7.expressionStatement(register));
    } else {
      body.push(...wrapHMR(ctx, checkScope ? scope.path : path4, register));
    }
  });
  const filename = ctx.options.filename;
  const loc = unwrapLoc(path4.node.loc);
  const nameLoc = unwrapLoc((_a = getDescriptiveNamePath(path4)) == null ? void 0 : _a.node.loc);
  if (!store.componentData[filename]) {
    store.componentData[filename] = {
      components: /* @__PURE__ */ Object.create(null)
    };
  }
  const file = store.componentData[filename];
  const prev = file.components[componentName];
  file.components[componentName] = {
    externals: getExternals(path4, componentName),
    loc: loc || (prev == null ? void 0 : prev.loc),
    nameLoc: nameLoc || (prev == null ? void 0 : prev.nameLoc)
  };
  if (!ctx.options.test) {
    store.report();
  }
};

// compiler/src/core/capture/transform.ts
init_esm_shims();
import * as t9 from "@babel/types";

// compiler/src/core/utils/get-definition.ts
init_esm_shims();
import * as t8 from "@babel/types";
var getDefinitionFromExpression = (ctx, path4, registration) => {
  const id = unwrapNode(path4.node, t8.isIdentifier);
  if (id) {
    const binding = path4.scope.getBindingIdentifier(id.name);
    if (binding) {
      return ctx.registrations[registration].identifiers.get(binding);
    }
    return void 0;
  }
  const memberExpr = unwrapNode(path4.node, t8.isMemberExpression);
  if (memberExpr && !memberExpr.computed && t8.isIdentifier(memberExpr.property)) {
    const object = unwrapNode(memberExpr.object, t8.isIdentifier);
    const property = unwrapNode(memberExpr.property, t8.isIdentifier);
    if (object) {
      const binding = path4.scope.getBindingIdentifier(object.name);
      if (property && (binding == null ? void 0 : binding.name) === "React") {
        return ctx.preset.imports[registration].filter((r) => {
          return r.kind === "named" && r.name === property.name;
        })[0];
      }
    }
  }
  return void 0;
};
var getDefinitionFromCallee = (ctx, path4, registration) => {
  const callee = path4.get("callee");
  if (!callee.isExpression()) {
    return void 0;
  }
  return getDefinitionFromExpression(ctx, callee, registration);
};

// compiler/src/core/capture/types.ts
init_esm_shims();

// compiler/src/core/capture/transform.ts
var getDefaultHookDefinition = (ctx, id) => {
  return isHookName(ctx, id) ? {
    type: 4 /* Value */,
    import: {
      kind: "named",
      name: id.name,
      source: RUNTIME_SOURCE
    }
  } : void 0;
};
var getHookImportDefinitionFromIdentifier = (ctx, identifier6) => {
  const binding = identifier6.scope.getBindingIdentifier(identifier6.node.name);
  if (binding) {
    return ctx.registrations.hooks.identifiers.get(binding) || getDefaultHookDefinition(ctx, identifier6.node);
  }
  return getDefaultHookDefinition(ctx, identifier6.node);
};
var getHookImportDefinitionFromPropName = (definitions, propName) => {
  for (let i = 0, len = definitions.length; i < len; i++) {
    const def = definitions[i];
    if (def.import.kind === "default" && propName === "default") {
      return def;
    }
    if (def.import.kind === "named" && propName === def.import.name) {
      return def;
    }
  }
  return void 0;
};
var getHookImportDefinitionFromMemberExpression = (ctx, member) => {
  if (member.node.computed || !t9.isIdentifier(member.node.property)) {
    return void 0;
  }
  const object = unwrapPath(member.get("object"), t9.isIdentifier);
  if (object) {
    const binding = object.scope.getBindingIdentifier(object.node.name);
    if (binding) {
      const definitions = ctx.registrations.hooks.namespaces.get(binding);
      if (definitions) {
        return getHookImportDefinitionFromPropName(
          definitions,
          member.node.property.name
        ) || getDefaultHookDefinition(ctx, member.node.property);
      }
    }
  }
  return getDefaultHookDefinition(ctx, member.node.property);
};
var getHookImportDefinition = (ctx, path4) => {
  const callee = path4.get("callee");
  const identifier6 = unwrapPath(callee, t9.isIdentifier);
  if (identifier6) {
    return getHookImportDefinitionFromIdentifier(ctx, identifier6);
  }
  const member = unwrapPath(callee, t9.isMemberExpression);
  if (member) {
    return getHookImportDefinitionFromMemberExpression(ctx, member);
  }
  return void 0;
};
var transformCustomCaptureCall = (ctx, key, path4, index, mountInfo) => {
  const callee = path4.get("callee");
  if (!callee.isExpression()) {
    return false;
  }
  const definition = getDefinitionFromExpression(ctx, callee, "million");
  if (!definition || definition.kind !== "named" || definition.name !== "useCapture") {
    return false;
  }
  const args = path4.node.arguments;
  if (args.length !== 1) {
    return false;
  }
  args[1] = t9.stringLiteral(key);
  args[2] = t9.numericLiteral(encode(unwrapLoc(path4.node.loc)));
  args[3] = t9.numericLiteral(index++);
  args[4] = mountInfo || t9.nullLiteral();
  return true;
};
var getCaptureCallExpression = (ctx, capture, args) => {
  ctx.options.stats.captures++;
  return t9.callExpression(capture, [
    t9.numericLiteral(args.kind),
    t9.stringLiteral(args.key),
    args.value,
    args.loc ? t9.numericLiteral(args.loc) : t9.nullLiteral(),
    args.secondaryLoc ? t9.numericLiteral(args.secondaryLoc) : t9.nullLiteral(),
    args.locs ? t9.arrayExpression(args.locs.map((loc) => t9.numericLiteral(loc))) : t9.nullLiteral(),
    args.index !== null ? t9.numericLiteral(args.index) : t9.nullLiteral(),
    args.profilerType !== null ? t9.numericLiteral(args.profilerType) : t9.nullLiteral(),
    args.mountInfo || t9.nullLiteral()
  ]);
};
var getCaptureProps = (ctx, path4, capture, key, mountInfo, seen) => {
  if (!path4.node.params.length) {
    return [];
  }
  let target = path4.node.params[0];
  const loc = encode(unwrapLoc(target.loc));
  if (t9.isAssignmentPattern(target)) {
    target = target.left;
  }
  if (t9.isIdentifier(target)) {
    const captureProps2 = getCaptureCallExpression(ctx, capture, {
      kind: 2 /* Props */,
      key,
      value: target,
      loc,
      secondaryLoc: null,
      locs: null,
      index: 0,
      profilerType: null,
      mountInfo
    });
    seen.add(captureProps2);
    return [
      t9.expressionStatement(t9.assignmentExpression("=", target, captureProps2))
    ];
  }
  if (t9.isObjectPattern(target)) {
    if (target.properties.length > 0) {
      const propsID2 = generateUniqueName(path4, "props");
      const captureProps2 = getCaptureCallExpression(ctx, capture, {
        kind: 2 /* Props */,
        key,
        value: propsID2,
        loc,
        secondaryLoc: null,
        locs: null,
        index: 0,
        profilerType: null,
        mountInfo
      });
      seen.add(captureProps2);
      path4.node.params[0] = propsID2;
      return [
        t9.variableDeclaration("let", [
          t9.variableDeclarator(target, captureProps2)
        ])
      ];
    }
    return [];
  }
  if (t9.isRestElement(target)) {
    const identifier6 = unwrapNode(target.argument, t9.isIdentifier);
    if (identifier6) {
      const captureProps2 = getCaptureCallExpression(ctx, capture, {
        kind: 2 /* Props */,
        key,
        value: t9.memberExpression(identifier6, t9.numericLiteral(0), true),
        loc,
        secondaryLoc: null,
        locs: null,
        index: 0,
        profilerType: null,
        mountInfo
      });
      seen.add(captureProps2);
      return [t9.expressionStatement(captureProps2)];
    }
  }
  const propsID = generateUniqueName(path4, "props");
  const restID = generateUniqueName(path4, "rest");
  const captureProps = getCaptureCallExpression(ctx, capture, {
    kind: 2 /* Props */,
    key,
    value: propsID,
    loc,
    secondaryLoc: null,
    locs: null,
    index: 0,
    profilerType: null,
    mountInfo
  });
  seen.add(captureProps);
  const currentParams = path4.node.params;
  path4.node.params = [propsID, t9.restElement(restID)];
  return [
    t9.variableDeclaration("let", [
      t9.variableDeclarator(
        t9.arrayPattern(currentParams),
        t9.arrayExpression([captureProps, t9.spreadElement(restID)])
      )
    ])
  ];
};
var isCurrentlyInJSX = (path4) => {
  let parent = path4.parentPath;
  while (parent) {
    if (parent.isJSXSpreadAttribute()) {
      return false;
    }
    if (parent.isJSXSpreadChild()) {
      return false;
    }
    if (parent.isJSXExpressionContainer()) {
      return false;
    }
    if (parent.isJSXElement()) {
      return true;
    }
    if (parent.isJSXFragment()) {
      return true;
    }
    parent = parent.parentPath;
  }
  return false;
};
var transformComponent = (ctx, path4, type) => {
  const componentName = getDescriptiveName(path4);
  if (!componentName || BANNED_COMPONENTS.includes(componentName)) {
    return;
  }
  const seen = /* @__PURE__ */ new WeakSet();
  const capture = getImportIdentifier(ctx, path4, ANYA_CAPTURE);
  ctx.options.stats.components++;
  const key = `${encode(ctx.options.filename)}.${encode(componentName)}`;
  ctx.componentKeys[componentName] = key;
  const loc = encode(unwrapLoc(path4.node.loc));
  const mountInfo = generateUniqueName(path4, "_$");
  const captureMount = type === "component" ? getCaptureCallExpression(ctx, capture, {
    kind: 512 /* Baseline */,
    key,
    value: t9.nullLiteral(),
    loc,
    secondaryLoc: null,
    locs: null,
    index: null,
    profilerType: null,
    mountInfo: null
  }) : t9.nullLiteral();
  seen.add(captureMount);
  const replacements = [
    t9.variableDeclaration("let", [
      t9.variableDeclarator(mountInfo, captureMount)
    ])
  ];
  if (type === "component") {
    replacements.push(
      ...getCaptureProps(ctx, path4, capture, key, mountInfo, seen)
    );
  }
  if (isPathValid(path4, t9.isArrowFunctionExpression)) {
    const body = path4.get("body");
    if (isPathValid(body, t9.isExpression)) {
      body.replaceWith(
        t9.blockStatement([...replacements, t9.returnStatement(body.node)])
      );
    } else if (isPathValid(body, t9.isBlockStatement)) {
      body.unshiftContainer("body", replacements);
    }
  } else if (isPathValid(path4, t9.isFunctionExpression) || isPathValid(path4, t9.isFunctionDeclaration)) {
    path4.get("body").unshiftContainer("body", replacements);
  }
  let index = 1;
  path4.traverse({
    CallExpression(childPath) {
      if (seen.has(childPath.node)) {
        return;
      }
      seen.add(childPath.node);
      const functionParent = childPath.getFunctionParent();
      if (!(functionParent && functionParent === path4)) {
        return;
      }
      if (transformCustomCaptureCall(ctx, key, childPath, index, mountInfo))
        return;
      const definition = getHookImportDefinition(ctx, childPath);
      if (!definition) {
        return;
      }
      const loc2 = encode(unwrapLoc(childPath.node.loc));
      switch (definition.type) {
        case 1 /* Deps */: {
          if (t9.isExpression(childPath.node.arguments[0])) {
            const captured = getCaptureCallExpression(ctx, capture, {
              kind: 128 /* Function */,
              key,
              value: childPath.node.arguments[0],
              loc: loc2,
              secondaryLoc: null,
              locs: null,
              index: index++,
              profilerType: null,
              mountInfo
            });
            seen.add(captured);
            childPath.node.arguments[0] = captured;
          }
          const targetArgument = childPath.node.arguments[definition.argument];
          if (t9.isExpression(targetArgument) && type !== "function") {
            let locs = null;
            if (t9.isArrayExpression(targetArgument)) {
              locs = new Array(targetArgument.elements.length);
              for (let i = 0; i < targetArgument.elements.length; i++) {
                locs[i] = encode(unwrapLoc(targetArgument.elements[i].loc));
              }
            }
            const captured = getCaptureCallExpression(ctx, capture, {
              kind: definition.type,
              key,
              value: targetArgument,
              loc: loc2,
              secondaryLoc: null,
              locs,
              index: index++,
              profilerType: null,
              mountInfo
            });
            seen.add(captured);
            childPath.node.arguments[definition.argument] = captured;
          }
          childPath.skip();
          break;
        }
        case 4 /* Value */: {
          if (type === "function")
            break;
          const captured = getCaptureCallExpression(ctx, capture, {
            kind: definition.type,
            key,
            value: childPath.node,
            loc: loc2,
            secondaryLoc: null,
            locs: null,
            index: index++,
            profilerType: null,
            mountInfo
          });
          seen.add(captured);
          childPath.replaceWith(captured)[0].skip();
          break;
        }
      }
    },
    // captureError (ErrorBoundary)
    // ReturnStatement() {
    //   path.traverse({
    //     JSXElement(childPath) {
    //       if (seen.has(childPath.node)) {
    //         return;
    //       }
    //       seen.add(childPath.node);
    //       const currentlyInJSX = isCurrentlyInJSX(childPath);
    //       const captured = getCaptureCallExpression(ctx, capture, {
    //         kind: CaptureKind.Error,
    //         key,
    //         value: childPath.node,
    //         loc,
    //         secondaryLoc: null,
    //         locs: null,
    //         index: index++,
    //         profilerType: null,
    //         mountInfo,
    //       });
    //       seen.add(captured);
    //       // DO NOT SKIP
    //       childPath.replaceWith(
    //         currentlyInJSX ? t.jsxExpressionContainer(captured) : captured,
    //       );
    //       childPath.skip();
    //     },
    //   });
    // },
    JSXElement(childPath) {
      var _a;
      if (seen.has(childPath.node)) {
        return;
      }
      seen.add(childPath.node);
      const currentlyInJSX = isCurrentlyInJSX(childPath);
      const openingElement = childPath.get("openingElement");
      const name = openingElement.get("name");
      const identifier6 = unwrapPath(name, t9.isJSXIdentifier);
      const loc2 = encode(unwrapLoc(childPath.node.loc));
      const containerPath = path4.find((p) => p.isJSXExpressionContainer());
      let secondaryLoc = null;
      if (containerPath) {
        secondaryLoc = encode(unwrapLoc(containerPath.node.loc));
      }
      const noRef = t9.isJSXIdentifier(childPath.parent) && childPath.parent.name === childPath.parent.name.toLowerCase();
      const isLeaf = childPath.node.selfClosing || ((_a = childPath.node.children) == null ? void 0 : _a.length) === 0;
      let profilerType = null;
      if (isLeaf) {
        profilerType = 1 /* Leaf */;
      } else if (noRef) {
        profilerType = 0 /* NoRef */;
      }
      if (identifier6) {
        if (isCapitalized(identifier6.node.name) && !BANNED_COMPONENTS.includes(identifier6.node.name)) {
          const captured = getCaptureCallExpression(ctx, capture, {
            kind: 16 /* JSX */,
            key,
            value: childPath.node,
            loc: loc2,
            secondaryLoc,
            locs: null,
            index: index++,
            profilerType,
            mountInfo
          });
          seen.add(captured);
          childPath.replaceWith(
            currentlyInJSX ? t9.jsxExpressionContainer(captured) : captured
          );
        }
        return;
      }
      const member = unwrapPath(name, t9.isJSXMemberExpression);
      if (member) {
        const captured = getCaptureCallExpression(ctx, capture, {
          kind: 16 /* JSX */,
          key,
          value: childPath.node,
          loc: loc2,
          secondaryLoc,
          locs: null,
          index: index++,
          profilerType,
          mountInfo
        });
        seen.add(captured);
        childPath.replaceWith(
          currentlyInJSX ? t9.jsxExpressionContainer(captured) : captured
        );
      }
    },
    JSXAttribute(childPath) {
      if (seen.has(childPath.node)) {
        return;
      }
      const jsxId = childPath.node.name;
      if (!t9.isJSXIdentifier(jsxId))
        return;
      if (!jsxId.name.startsWith("on"))
        return;
      if (!t9.isJSXExpressionContainer(childPath.node.value))
        return;
      if (t9.isJSXEmptyExpression(childPath.node.value.expression))
        return;
      const elementId = unwrapPath(
        childPath.parentPath.get("name"),
        t9.isJSXIdentifier
      );
      if (!elementId)
        return;
      if (isCapitalized(elementId.node.name))
        return;
      seen.add(childPath.node);
      const expressionContainer = childPath.get(
        "value.expression"
      );
      const loc2 = encode(unwrapLoc(expressionContainer.node.loc));
      const captured = getCaptureCallExpression(ctx, capture, {
        kind: 128 /* Function */,
        key,
        value: childPath.node.value.expression,
        loc: loc2,
        secondaryLoc: null,
        locs: null,
        index: index++,
        profilerType: null,
        mountInfo
      });
      seen.add(captured);
      childPath.node.value.expression = captured;
      childPath.skip();
    }
  });
  registerMetadata(ctx, path4, key, index, componentName);
};

// compiler/src/core/presets.ts
init_esm_shims();
var createPreset = (preset) => {
  return preset;
};
var PRESETS = {
  react: createPreset({
    filters: {
      component: {
        source: "^[A-Z]",
        flags: ""
      },
      hook: {
        source: "^use[A-Z]",
        flags: ""
      }
    },
    imports: {
      hooks: [
        // React hooks
        {
          type: 1 /* Deps */,
          import: {
            kind: "named",
            source: "react",
            name: "useEffect"
          },
          argument: 1
        },
        {
          type: 1 /* Deps */,
          import: {
            kind: "named",
            source: "react",
            name: "useLayoutEffect"
          },
          argument: 1
        },
        {
          type: 1 /* Deps */,
          import: {
            kind: "named",
            source: "react",
            name: "useMemo"
          },
          argument: 1
        },
        {
          type: 1 /* Deps */,
          import: {
            kind: "named",
            source: "react",
            name: "useCallback"
          },
          argument: 1
        },
        {
          type: 1 /* Deps */,
          import: {
            kind: "named",
            source: "react",
            name: "useInsertionEffect"
          },
          argument: 1
        },
        {
          type: 4 /* Value */,
          import: {
            kind: "named",
            source: "react",
            name: "useState"
          }
        },
        {
          type: 4 /* Value */,
          import: {
            kind: "named",
            source: "react",
            name: "useReducer"
          }
        },
        {
          type: 4 /* Value */,
          import: {
            kind: "named",
            source: "react",
            name: "useContext"
          }
        }
      ],
      hocs: [
        {
          name: "forwardRef",
          source: "react",
          kind: "named"
        },
        {
          name: "memo",
          source: "react",
          kind: "named"
        }
      ],
      million: [
        {
          name: "init",
          source: "@million/lint/runtime",
          kind: "named"
        },
        {
          name: "useCapture",
          source: "@million/lint/runtime",
          kind: "named"
        },
        {
          name: "init",
          source: "@million/lint/runtime-dev",
          kind: "named"
        },
        {
          name: "useCapture",
          source: "@million/lint/runtime-dev",
          kind: "named"
        }
      ],
      classes: [
        {
          name: "Component",
          source: "react",
          kind: "named"
        },
        {
          name: "PureComponent",
          source: "react",
          kind: "named"
        }
      ]
    }
  })
};

// compiler/src/core/utils/get-commit-hash.ts
init_esm_shims();
import { execSync } from "child_process";
var COMMIT_HASH_REGEX = new RegExp(/^[a-f0-9]{40}$/i, "g");
var testCommitHash = (str) => {
  return typeof str === "string" && COMMIT_HASH_REGEX.test(str) ? str : void 0;
};
var getCommitHash = () => {
  const hash = testCommitHash(process.env.MILLION_COMMIT_SHA) ?? testCommitHash(process.env.VERCEL_GIT_COMMIT_SHA) ?? testCommitHash(process.env.GITHUB_SHA) ?? testCommitHash(process.env.COMMIT_REF) ?? testCommitHash(process.env.HEROKU_SLUG_COMMIT) ?? testCommitHash(process.env.SOURCE_VERSION) ?? testCommitHash(execSync("git rev-parse HEAD").toString().trim());
  if (!hash) {
    throw new Error(
      // TODO make the message a constant
      "Could not find a commit hash to identify your build! In your CI/CD .env. Please email aiden@million.dev for support.",
      {
        cause: "No git commit hash found"
      }
    );
  }
  return hash;
};

// compiler/src/core/plugin.ts
var registerHookSpecifiers = (ctx, path4, hook) => {
  let specifier;
  for (let i = 0, len = path4.node.specifiers.length; i < len; i++) {
    specifier = path4.node.specifiers[i];
    switch (specifier.type) {
      case "ImportDefaultSpecifier": {
        if (hook.import.kind === "default") {
          ctx.registrations.hooks.identifiers.set(specifier.local, hook);
        }
        break;
      }
      case "ImportNamespaceSpecifier": {
        let current = ctx.registrations.hooks.namespaces.get(specifier.local);
        if (!current) {
          current = [];
        }
        current.push(hook);
        ctx.registrations.hooks.namespaces.set(specifier.local, current);
        break;
      }
      case "ImportSpecifier": {
        if (hook.import.kind === "named" && getImportSpecifierName(specifier) === hook.import.name || hook.import.kind === "default" && getImportSpecifierName(specifier) === "default") {
          ctx.registrations.hooks.identifiers.set(specifier.local, hook);
        }
        break;
      }
    }
  }
};
var registerSpecifiers = (ctx, path4, hoc, registration) => {
  let specifier;
  for (let i = 0, len = path4.node.specifiers.length; i < len; i++) {
    specifier = path4.node.specifiers[i];
    switch (specifier.type) {
      case "ImportDefaultSpecifier": {
        if (hoc.kind === "default") {
          ctx.registrations[registration].identifiers.set(specifier.local, hoc);
        }
        break;
      }
      case "ImportNamespaceSpecifier": {
        let current = ctx.registrations[registration].namespaces.get(
          specifier.local
        );
        if (!current) {
          current = [];
        }
        current.push(hoc);
        ctx.registrations[registration].namespaces.set(
          specifier.local,
          current
        );
        break;
      }
      case "ImportSpecifier": {
        if (hoc.kind === "named" && getImportSpecifierName(specifier) === hoc.name || hoc.kind === "default" && getImportSpecifierName(specifier) === "default") {
          ctx.registrations[registration].identifiers.set(specifier.local, hoc);
        }
        break;
      }
    }
  }
};
var extractImportIdentifiers = (ctx, path4) => {
  const mod = path4.node.source.value;
  if (mod.includes("@million/lint/runtime") && mod !== RUNTIME_SOURCE) {
    path4.node.source.value = RUNTIME_SOURCE;
  }
  const { imports } = ctx.preset;
  let hook;
  for (let i = 0, len = imports.hooks.length; i < len; i++) {
    hook = imports.hooks[i];
    if (mod === hook.import.source) {
      registerHookSpecifiers(ctx, path4, hook);
    }
  }
  let hoc;
  for (let i = 0, len = imports.hocs.length; i < len; i++) {
    hoc = imports.hocs[i];
    if (mod === hoc.source) {
      registerSpecifiers(ctx, path4, hoc, "hocs");
    }
  }
  let million;
  for (let i = 0, len = imports.million.length; i < len; i++) {
    million = imports.million[i];
    if (mod === million.source) {
      registerSpecifiers(ctx, path4, million, "million");
    }
  }
  let currentClass;
  for (let i = 0, len = imports.classes.length; i < len; i++) {
    currentClass = imports.classes[i];
    if (mod === currentClass.source) {
      registerSpecifiers(ctx, path4, currentClass, "classes");
    }
  }
};
var transformFunction = (ctx, path4, type) => {
  const unwrapped = unwrapPath(path4, isComponent);
  if (unwrapped && type) {
    if (unwrapped.node.async || unwrapped.node.generator) {
      return;
    }
    transformComponent(ctx, unwrapped, type);
  }
};
var transformInit = (ctx, path4) => {
  const definition = getDefinitionFromCallee(ctx, path4, "million");
  if (definition && definition.kind === "named" && definition.name === "init") {
    path4.node.arguments[0] = t10.objectExpression([
      t10.objectProperty(
        t10.identifier("url"),
        ctx.options.framework === "next" && process.env.NODE_ENV === "production" ? t10.stringLiteral("/__anya") : t10.nullLiteral()
      ),
      t10.objectProperty(t10.identifier("id"), t10.stringLiteral(getCommitHash())),
      t10.objectProperty(
        t10.identifier("apiKey"),
        t10.stringLiteral(
          process.env.NODE_ENV === "production" ? ctx.options.apiKey || "" : "dev"
        )
      )
    ]);
  }
};
var transformHOC = (ctx, path4) => {
  if (path4.node.arguments.length === 0) {
    return;
  }
  const definition = getDefinitionFromCallee(ctx, path4, "hocs");
  if (definition) {
    const argument = path4.get("arguments")[0];
    transformFunction(ctx, argument, "component");
  }
};
var transformVariableDeclarator = (ctx, path4) => {
  if (path4.node.init && t10.isIdentifier(path4.node.id)) {
    const componentNode = path4.get("init");
    const type = getTypeFromComponentName(ctx, componentNode, path4.node.id);
    if (!type)
      return;
    transformFunction(ctx, componentNode, type);
    const id = path4.node.id;
    path4.get("init").traverse({
      Identifier(childPath) {
        const key = ctx.componentKeys[childPath.node.name];
        if (key) {
          registerMetadata(ctx, path4, key, -1, id.name, false);
          childPath.stop();
        }
      }
    });
  }
};
var babelPlugin = (_, options = {}) => {
  return {
    name: "anya",
    visitor: {
      Program(programPath) {
        var _a;
        const comments = programPath.node.leadingComments;
        if (comments) {
          for (let i = 0, len = comments.length; i < len; i++) {
            if (comments[i].value === ANYA_IGNORE) {
              return;
            }
          }
        }
        let hasUseClientDirective = false;
        for (let i = 0, len = (_a = programPath.node.directives) == null ? void 0 : _a.length; i < len; i++) {
          const directive = programPath.node.directives[i];
          const directiveValue = directive.value.value;
          if (directiveValue === "use server") {
            options.rsc = true;
            return;
          }
          if (directiveValue === "use client") {
            hasUseClientDirective = true;
            break;
          }
        }
        const preset = PRESETS.react;
        const ctx = {
          imports: /* @__PURE__ */ new Map(),
          registrations: {
            React: void 0,
            hooks: {
              identifiers: /* @__PURE__ */ new Map(),
              namespaces: /* @__PURE__ */ new Map()
            },
            hocs: {
              identifiers: /* @__PURE__ */ new Map(),
              namespaces: /* @__PURE__ */ new Map()
            },
            million: {
              identifiers: /* @__PURE__ */ new Map(),
              namespaces: /* @__PURE__ */ new Map()
            },
            classes: {
              identifiers: /* @__PURE__ */ new Map(),
              namespaces: /* @__PURE__ */ new Map()
            }
          },
          options,
          queue: [],
          preset,
          componentKeys: /* @__PURE__ */ Object.create(null),
          filters: {
            component: new RegExp(
              preset.filters.component.source,
              preset.filters.component.flags
            ),
            hook: preset.filters.hook ? new RegExp(
              preset.filters.hook.source,
              preset.filters.hook.flags
            ) : void 0
          }
        };
        programPath.traverse({
          ImportDeclaration(path4) {
            extractImportIdentifiers(ctx, path4);
          }
        });
        if (options.rsc && !hasUseClientDirective && !ctx.registrations.hooks.identifiers.size && !ctx.registrations.hocs.identifiers.size) {
          return;
        }
        programPath.traverse({
          CallExpression(path4) {
            transformInit(ctx, path4);
            transformHOC(ctx, path4);
          },
          FunctionDeclaration(path4) {
            transformFunction(ctx, path4, getComponentType(ctx, path4));
          },
          FunctionExpression(path4) {
            transformFunction(ctx, path4, getComponentType(ctx, path4));
          },
          VariableDeclarator(path4) {
            transformVariableDeclarator(ctx, path4);
          }
          // ClassExpression(path) {
          //   transformClassComponent(ctx, path);
          // },
          // ClassDeclaration(path) {
          //   transformClassComponent(ctx, path);
          // },
        });
        if (!ctx.queue.length)
          return;
        for (let i = 0, len = ctx.queue.length; i < len; i++) {
          ctx.queue[i]();
        }
      }
    }
  };
};

// compiler/src/core/compile.ts
var compile = async (id, code, options) => {
  var _a;
  const parserPlugins = [
    "jsx",
    // import { example } from 'example' with { example: true };
    [
      "importAttributes",
      {
        deprecatedAssertSyntax: false
      }
    ],
    // () => throw example
    "throwExpressions",
    // You know what this is
    "decorators",
    // const { #example: example } = this;
    "destructuringPrivate",
    // using example = myExample()
    "explicitResourceManagement",
    // import.meta
    "importMeta"
  ];
  const buildPlugins = [];
  const overridePlugins = (_a = options.babel) == null ? void 0 : _a.plugins;
  if (overridePlugins) {
    for (let i = 0, len = overridePlugins.length; i < len; i++) {
      const plugin = overridePlugins[i];
      buildPlugins.unshift(plugin);
    }
  }
  buildPlugins.push([babelPlugin, options]);
  const isTSX = /\.[mc]?tsx?$/i.test(id);
  if (isTSX) {
    parserPlugins.push("typescript");
  } else {
    buildPlugins.unshift(hermesParser);
  }
  const result = await transformAsync(code, {
    plugins: buildPlugins,
    ignore: [/\/(?<c>build|node_modules)\//],
    parserOpts: isTSX ? { plugins: parserPlugins } : void 0,
    cloneInputAst: false,
    generatorOpts: {
      // https://github.com/facebook/react/issues/29120
      // TODO: remove once React Compiler has provided their workaround
      jsescOption: {
        minimal: true
      }
    },
    filename: id,
    ast: false,
    sourceFileName: id,
    sourceMaps: true,
    configFile: false,
    babelrc: false
  });
  return result ? { code: result.code || "", map: result.map } : null;
};

// compiler/src/server/index.ts
init_esm_shims();
import { serve } from "@hono/node-server";

// compiler/src/server/ingest.ts
init_esm_shims();
import { Hono } from "hono";
import { cors } from "hono/cors";

// compiler/src/server/middleware/decompress.ts
init_esm_shims();
var decompress = () => {
  return async (ctx, next3) => {
    ctx.req.jsonWithCompression = async () => {
      if (!ctx.req.query("z")) {
        return ctx.req.json();
      }
      try {
        const stream = new DecompressionStream("gzip");
        const decoder = new TextDecoder();
        const buffer = await ctx.req.blob();
        const decompressStream = buffer.stream().pipeThrough(stream);
        const reader = decompressStream.getReader();
        const text = await reader.read();
        return JSON.parse(decoder.decode(text.value));
      } catch (err) {
        if (err instanceof Error) {
          void saveLog("error", {
            origin: "Failed to decompress request",
            message: err.message,
            stack: err.stack
          });
        }
        return {};
      }
    };
    await next3();
  };
};

// compiler/src/server/ingest.ts
var ingestServer = new Hono();
ingestServer.use(cors()).use(decompress()).post("/ingest", async (c) => {
  const body = await c.req.jsonWithCompression();
  if (!body)
    return c.json({ status: "Body invalid. Please try again!" });
  if (store.sessionId)
    return c.json({ status: "Using Sessions" });
  await report({
    runtime: body,
    compiler: store.get()
  });
  return c.json({ ok: true });
}).get("/ingest/reset", async (c) => {
  void reset2();
  return c.json({ ok: true });
}).get("/ingest/healthcheck", async (c) => {
  const sessions = [];
  for await (const session of getPossibleConnections()) {
    sessions.push(session);
  }
  return c.json({ ok: sessions.length, sessions });
}).get("/data", (c) => {
  return c.json(store.get());
}).get("/shutdown", (c) => {
  shutdown();
  return c.json({ status: "Server shutdown" });
}).get("/test-connection", async (c) => {
  const sessions = [];
  const connections = [];
  for await (const connection of getPossibleConnections()) {
    connections.push(connection);
  }
  for await (const session of getSessions()) {
    sessions.push(session);
  }
  return c.json({ sessions, connections });
}).all("*", (c) => c.text(c.req.url));

// compiler/src/server/index.ts
var INITIAL_PORT = 42423;
var server;
var numberOfTries = 5;
var alreadyNotified = false;
var shutdown = () => {
  if (server) {
    server.close();
  }
};
var startIngestServer = async (ingest) => {
  ingest ?? (ingest = {});
  if (server)
    return server;
  const host = (ingest == null ? void 0 : ingest.host) || "localhost";
  let port = (ingest == null ? void 0 : ingest.port) || INITIAL_PORT;
  while (!server && numberOfTries > 0) {
    try {
      server = await _startIngestServer(host, port);
    } catch (err) {
      if (err instanceof Error) {
        void saveLog("error", {
          origin: "Failed to start ingest server",
          message: err.message,
          stack: err.stack,
          numberOfTries,
          host: (ingest == null ? void 0 : ingest.host) || "localhost",
          port
        });
      }
    }
    if (server) {
      store.port = port;
      return server;
    }
    port++;
    numberOfTries--;
  }
  if (!server) {
    if (!alreadyNotified) {
      alreadyNotified = true;
      logError("Could not connect to VSCode.");
      void saveLog("error", {
        origin: "Could not connect to VSCode",
        port
      });
    }
  }
  if (ingest) {
    ingest.port = port;
    ingest.host = host;
  }
  return server;
};
var _startIngestServer = async (host, port) => {
  const url = `http://${host}:${port}`;
  try {
    await fetch(`${url}/shutdown`, { method: "GET", mode: "no-cors" });
  } catch (err) {
    if (err instanceof Error) {
      void saveLog("error", {
        origin: "Failed to shutdown ingest server",
        message: err.message,
        stack: err.stack,
        port
      });
    }
  }
  return new Promise((resolve) => {
    const server2 = serve({
      fetch: ingestServer.fetch,
      hostname: host,
      port
    }).listen(port);
    server2.on("listening", () => resolve(server2));
    server2.on("error", (err) => {
      void saveLog("error", {
        origin: "Failed to start ingest server",
        message: err.message,
        stack: err.stack,
        port
      });
      resolve(void 0);
    });
  }).catch((err) => {
    void saveLog("error", {
      origin: "Failed to start ingest server",
      message: err.message,
      stack: err.stack,
      port
    });
    return void 0;
  });
};

// compiler/src/store.ts
init_esm_shims();
var import_debounce = __toESM(require_debounce());
import fs2 from "fs";
import path2 from "path";

// compiler/src/core/utils/encoder.ts
init_esm_shims();
var Encoder = class {
  constructor(encoded = new Array(), cache2 = /* @__PURE__ */ new Map()) {
    this.encoded = encoded;
    this.cache = cache2;
    this.hasChanged = true;
  }
  serialize() {
    return this.encoded;
  }
  deserialize(data) {
    if (this.encoded.length !== 0)
      return;
    for (let i = 0, len = data.length; i < len; i++) {
      this.push(data[i]);
    }
  }
  push(value) {
    this.hasChanged = true;
    const key = value.toString();
    if (this.cache.has(key)) {
      return this.cache.get(key);
    }
    const index = this.encoded.push(value) - 1;
    this.cache.set(key, index);
    return index;
  }
  get(index) {
    return this.encoded[index] ?? null;
  }
  all() {
    return this.encoded;
  }
  clear() {
    this.encoded.length = 0;
    this.cache.clear();
  }
};

// compiler/src/store.ts
var cwd = process.cwd();
var Store = class {
  constructor(cacheHandler = buildCacheHandler(process.cwd(), "store.json"), report2 = (0, import_debounce.default)(
    () => {
      if (!this.encodings.hasChanged)
        return;
      this.cacheHandler.write(this.serialize());
      void report({ compiler: this.get() });
    },
    1e3,
    { leading: true, trailing: false }
  )) {
    this.cacheHandler = cacheHandler;
    this.report = report2;
    /* Encoding */
    this.encodings = new Encoder();
    /* Component Data (Component Locs, Externals) */
    this.componentData = {};
    /* Debugging */
    this.failedFiles = new Array();
    this.port = 42423;
    let data;
    try {
      data = this.cacheHandler.load();
    } catch (err) {
      logError("Failed to load data from disk");
      if (err instanceof Error) {
        void saveLog("error", {
          origin: "Failed to load data from disk",
          message: err.message,
          stack: err.stack
        });
      }
    }
    if (data) {
      try {
        this.deserialize(data);
      } catch (err) {
        logError("Failed to deserialize data from disk");
        if (err instanceof Error) {
          void saveLog("error", {
            origin: "Failed to deserialize data from disk",
            message: err.message,
            stack: err.stack,
            data
          });
        }
      }
    }
    process.on("exit", () => {
      this.cacheHandler.write(this.serialize());
    });
  }
  get() {
    const data = {
      encodings: this.encodings.all(),
      componentData: this.componentData,
      failedFiles: this.failedFiles,
      cwd
    };
    return data;
  }
  clear() {
    this.encodings.clear();
    this.componentData = {};
  }
  serialize() {
    this.encodings.hasChanged = false;
    return {
      encodings: this.encodings.serialize(),
      componentData: this.componentData
    };
  }
  deserialize(data) {
    this.encodings.deserialize(data.encodings);
    this.componentData = data.componentData;
  }
};
var buildCacheHandler = (cwd3, file) => {
  return {
    write: (data) => {
      const baseDir = path2.join(cwd3, ".million");
      try {
        if (!fs2.existsSync(path2.join(baseDir))) {
          fs2.mkdirSync(path2.join(baseDir));
        }
        fs2.writeFileSync(path2.join(baseDir, file), JSON.stringify(data));
      } catch (err) {
        logError("Failed to write cache to disk");
        if (err instanceof Error) {
          void saveLog("error", {
            origin: "Failed to write cache to disk",
            message: err.message,
            stack: err.stack,
            baseDir
          });
        }
      }
    },
    load: () => {
      const baseDir = path2.join(cwd3, ".million");
      try {
        if (!fs2.existsSync(path2.join(baseDir, file))) {
          return null;
        }
        return JSON.parse(
          fs2.readFileSync(path2.join(baseDir, file), "utf8")
        );
      } catch (err) {
        logError("Failed to delete cache from disk");
        if (err instanceof Error) {
          void saveLog("error", {
            origin: "Failed to delete cache from disk",
            message: err.message,
            stack: err.stack,
            baseDir
          });
        }
        return null;
      }
    }
  };
};

// compiler/src/server/session.ts
init_esm_shims();
var import_debounce2 = __toESM(require_debounce());
import io from "socket.io-client";
var debouncedReport = (0, import_debounce2.default)(
  () => report({ compiler: store.get() }),
  1e3,
  { leading: true, trailing: false }
);
var startProxySession = async (proxy) => {
  if (!(proxy == null ? void 0 : proxy.enabled)) {
    void saveLog("info", { origin: "Proxy session disabled" });
    return;
  }
  void saveLog("info", { origin: "Proxy session enabled" });
  try {
    const url = `${(proxy == null ? void 0 : proxy.url) ?? "https://lint.million.dev"}/api/v1/proxy`;
    const session = await fetch(`${url}/session`, {
      method: "POST",
      body: JSON.stringify({ password: proxy == null ? void 0 : proxy.password }),
      headers: { "Content-Type": "application/json" }
    });
    if (!session.ok) {
      throw new Error(
        `Failed to start proxy session: ${session.status} ${session.statusText}`
      );
    }
    const data = await session.json();
    store.sessionId = data.sessionId;
    store.proxyUrl = url;
    const socket = io("wss://socket.million.dev", {
      auth: { roomId: store.sessionId },
      transports: ["websocket"]
    });
    socket.on("connect", async () => {
      socket.on("need-compiler", async () => {
        await debouncedReport();
      });
      void saveLog("info", {
        origin: "Proxy session connected",
        sessionId: store.sessionId
      });
      const connect = async () => {
        for await (const { port, host } of getSessions()) {
          void fetch(`http://${host}:${port}/session`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ id: store.sessionId })
          }).catch((err) => {
            void saveLog("error", {
              origin: "Failed to send data to ingest server",
              message: err.message,
              stack: err.stack
            });
          });
        }
      };
      await connect();
      setInterval(async () => {
        await connect();
      }, 5e3);
    });
    void saveLog("info", {
      origin: "Proxy session started",
      sessionId: store.sessionId
    });
  } catch (err) {
    if (err instanceof Error) {
      void saveLog("error", {
        origin: "Failed to start proxy session",
        message: err.message,
        stack: err.stack,
        proxy: proxy ?? {}
      });
    }
  }
};

// compiler/src/index.ts
var cwd2 = process.cwd();
var DEFAULT_INCLUDE = "**/*.{mtsx,mjsx,tsx,jsx}";
var DEFAULT_EXCLUDE = "**/node_modules/**/*";
var cacheDirs = [".cache/", ".vite/"];
var store = new Store();
var encode = (secret) => {
  return store.encodings.push(secret);
};
var init2;
var unplugin = createUnplugin((options, meta) => {
  var _a, _b;
  const currentOptions = options || {};
  const filter = createFilter(
    ((_a = currentOptions.filter) == null ? void 0 : _a.include) || DEFAULT_INCLUDE,
    ((_b = currentOptions.filter) == null ? void 0 : _b.exclude) || [
      DEFAULT_EXCLUDE,
      // Next.js pages dir specific
      "**/_app.{jsx,tsx,js,ts}",
      "**/_document.{jsx,tsx,js,ts}"
    ]
  );
  let time = null;
  let totalTime = 0;
  if (!currentOptions.ingest) {
    currentOptions.ingest = {
      host: "localhost",
      port: INITIAL_PORT
    };
  }
  if (currentOptions.test === void 0) {
    currentOptions.test = process.env.NODE_ENV === "test";
  }
  if (!currentOptions.test && process.env.NODE_ENV !== "production") {
    init2 = async () => {
      var _a2;
      await Promise.all([
        startIngestServer(currentOptions.ingest),
        startProxySession(currentOptions.proxy),
        reset2()
      ]);
      displayIntro((_a2 = currentOptions.ingest) == null ? void 0 : _a2.port, store.sessionId);
    };
  }
  const stats = {
    components: 0,
    captures: 0
  };
  return {
    enforce: "pre",
    name: "anya",
    watchChange() {
      totalTime = 0;
      void reset2();
    },
    transformInclude(id) {
      return filter(id);
    },
    async transform(code, id) {
      if (init2) {
        await init2();
        init2 = void 0;
      }
      if (options == null ? void 0 : options.skipTransform) {
        return null;
      }
      const relativePath = path3.relative(cwd2, id);
      let withBabelOptions = options;
      try {
        if (cacheDirs.some((dir) => id.includes(dir))) {
          return null;
        }
        if (currentOptions.dev) {
          time = logStart(relativePath);
        }
        withBabelOptions = Object.assign(
          {
            source: code,
            filename: relativePath,
            absoluteFilename: id,
            framework: meta.framework,
            stats: {
              components: 0,
              captures: 0
            }
          },
          options
        );
        stats.components += withBabelOptions.stats.components;
        stats.captures += withBabelOptions.stats.captures;
        const result = await compile(id, code, withBabelOptions);
        if (currentOptions.dev) {
          totalTime += logEnd(relativePath, time, withBabelOptions.stats);
        }
        return result;
      } catch (err) {
        if (err instanceof Error) {
          store.failedFiles.push({
            filename: relativePath,
            error: err.message
          });
          if ((options == null ? void 0 : options.telemetry) !== false) {
            void saveLog("error", {
              origin: "Failed to compile",
              message: err.message,
              stack: err.stack,
              options: withBabelOptions,
              stats,
              totalTime,
              code
            });
          }
        }
        logError(
          `Failed to compile: ${relativePath} 
 ${err.message} ${(options == null ? void 0 : options.dev) ? err.stack : ""}`
        );
      }
      return null;
    },
    buildEnd() {
      store.report();
      if (options == null ? void 0 : options.skipTransform) {
        return;
      }
      logFinish(totalTime, stats);
    },
    webpack(compiler) {
      if (process.env.NODE_ENV !== "production")
        return;
      const options2 = compiler.options;
      if (!options2.resolve) {
        options2.resolve = {};
      }
      if (!options2.resolve.alias) {
        options2.resolve.alias = {};
      }
      if (Array.isArray(options2.resolve.alias)) {
        options2.resolve.alias.push({
          alias: "react-dom$",
          name: "react-dom/profiling"
        });
      } else {
        options2.resolve.alias["react-dom$"] = "react-dom/profiling";
      }
    },
    vite: {
      resolve: {
        alias: [
          { find: /^react-dom$/, replacement: "react-dom/profiling" },
          {
            find: "scheduler/tracing",
            replacement: "scheduler/tracing-profiling"
          }
        ]
      },
      handleHotUpdate(e) {
        if (e.file.includes(".million"))
          return;
        totalTime = 0;
        void reset2();
        store.report();
      },
      configResolved(config) {
        repushPlugin(config.plugins, "anya", [
          // https://github.com/withastro/astro/blob/main/packages/astro/src/vite-plugin-jsx/index.ts#L173
          "astro:jsx",
          // https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react
          "vite:react-babel",
          "vite:react-jsx",
          // https://github.com/preactjs/preset-vite/blob/main/src/index.ts
          "vite:preact-jsx",
          // https://github.com/vitejs/vite-plugin-react-swc/blob/main/src/index.ts
          "vite:react-swc"
        ]);
      }
    }
  };
});
var repushPlugin = (plugins, pluginName, pluginNames) => {
  const namesSet = new Set(pluginNames);
  let baseIndex = -1;
  let targetIndex = -1;
  let targetPlugin;
  for (let i = 0, len = plugins.length; i < len; i += 1) {
    const current = plugins[i];
    if (namesSet.has(current.name) && baseIndex === -1) {
      baseIndex = i;
    }
    if (current.name === pluginName) {
      targetIndex = i;
      targetPlugin = current;
    }
  }
  if (targetPlugin && baseIndex !== -1 && targetIndex !== -1 && baseIndex < targetIndex) {
    plugins.splice(targetIndex, 1);
    plugins.splice(baseIndex, 0, targetPlugin);
  }
};

// compiler/vite.ts
var vite = unplugin.vite;
var vite_default = vite;

// compiler/rollup.ts
init_esm_shims();
var rollup = unplugin.rollup;
var rollup_default = rollup;

// compiler/esbuild.ts
init_esm_shims();
var esbuild = unplugin.esbuild;
var esbuild_default = esbuild;

// compiler/next.ts
init_esm_shims();
var next = (options = {}) => {
  return (nextConfig = {}) => {
    if (Array.isArray(nextConfig)) {
      nextConfig.push(next(options));
      return nextConfig;
    } else if (typeof nextConfig === "function") {
      return async (phase, config) => {
        const baseConfig = await nextConfig(phase, config);
        return {
          ...baseConfig,
          ...next(options)(baseConfig)
        };
      };
    }
    return {
      ...nextConfig,
      async rewrites() {
        var _a;
        const prevRewrites = await ((_a = nextConfig.rewrites) == null ? void 0 : _a.call(nextConfig)) || [];
        const obj = {
          source: "/__anya",
          destination: "https://lint.million.dev/api/v1/ingest"
        };
        if (Array.isArray(prevRewrites)) {
          return [...prevRewrites, obj];
        } else if (prevRewrites instanceof Object) {
          return {
            ...prevRewrites,
            fallback: [...prevRewrites.fallback || [], obj]
          };
        }
        return [obj];
      },
      webpack: (config, webpackOptions) => {
        config.plugins.push(
          unplugin.webpack({
            framework: "next",
            ...options
          })
        );
        if (typeof nextConfig.webpack === "function") {
          return nextConfig.webpack(config, webpackOptions);
        }
        return config;
      }
    };
  };
};
var next_default = next;

// compiler/craco.ts
init_esm_shims();
var craco = (options) => {
  return {
    options,
    plugin: {
      overrideWebpackConfig: ({ webpackConfig, pluginOptions }) => {
        webpackConfig.plugins.unshift(unplugin.webpack(pluginOptions));
        return webpackConfig;
      },
      overrideDevServerConfig: ({ devServerConfig }) => {
        devServerConfig.hot = false;
        devServerConfig.liveReload = false;
        devServerConfig.watchFiles = [];
        return devServerConfig;
      }
    }
  };
};
var craco_default = craco;

// compiler/astro.ts
init_esm_shims();
var astro_default = (options = {}) => ({
  name: "anya",
  hooks: {
    "astro:config:setup": (astro2) => {
      var _a;
      (_a = astro2.config.vite).plugins || (_a.plugins = []);
      astro2.config.vite.plugins.push(vite(options));
    }
  }
});

// compiler/webpack.ts
init_esm_shims();
var webpack = unplugin.webpack;
var webpack_default = webpack;

// compiler/rspack.ts
init_esm_shims();
var rollup2 = unplugin.rollup;
var rspack_default = rollup2;

// compiler/rewire.ts
init_esm_shims();
var rewire = (config, _env, options) => {
  config.plugins.push(unplugin.webpack(options));
  return config;
};
var rewire_default = rewire;

// compiler/index.ts
var esbuild2 = esbuild_default;
var rollup3 = rollup_default;
var vite2 = vite_default;
var next2 = next_default;
var unplugin2 = unplugin;
var craco2 = craco_default;
var astro = astro_default;
var babel = babelPlugin;
var rspack = rspack_default;
var webpack2 = webpack_default;
var rewire2 = rewire_default;
var compiler_default = {
  vite: vite2,
  rollup: rollup3,
  esbuild: esbuild2,
  next: next2,
  unplugin: unplugin2,
  craco: craco2,
  astro,
  babel,
  rspack,
  webpack: webpack2,
  rewire: rewire2
};
export {
  astro,
  babel,
  craco2 as craco,
  compiler_default as default,
  esbuild2 as esbuild,
  next2 as next,
  rewire2 as rewire,
  rollup3 as rollup,
  rspack,
  unplugin2 as unplugin,
  vite2 as vite,
  webpack2 as webpack
};
