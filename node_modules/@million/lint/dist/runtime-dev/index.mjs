var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// runtime/src/core/utils/constants.ts
var _null, isSSR, _window, _document, _Map, _Object, _Array, _isArray, _setTimeout, _performance, _Function, functionProto, mapProto, _mapHas, _mapGet, _mapSet, objectPrototype, _objectHasOwnProperty, _objectToString, UNKNOWN, VERSION, FLAG, MAX_QUEUE_SIZE, FLUSH_TIMEOUT, SESSION_EXPIRE_TIMEOUT, GZIP_MIN_LEN, ENDPOINT, REACT_PREFIX, ELEMENT_SYMBOL_STRING, FORWARD_REF_SYMBOL_STRING, LAZY_SYMBOL_STRING, MEMO_SYMBOL_STRING, FRAGMENT_SYMBOL_STRING, PORTAL_SYMBOL_STRING, PROFILER_SYMBOL_STRING, STRICT_MODE_SYMBOL_STRING, SUSPENSE_SYMBOL_STRING, SUSPENSE_LIST_SYMBOL_STRING, MOBX_SYMBOL_STRING, PROFILER_DISPLAY_NAME, VOID_ELEMENTS;
var init_constants = __esm({
  "runtime/src/core/utils/constants.ts"() {
    "use strict";
    _null = null;
    isSSR = typeof window === "undefined";
    _window = isSSR ? _null : window;
    _document = isSSR ? _null : document;
    _Map = Map;
    _Object = Object;
    _Array = Array;
    _isArray = _Array.isArray;
    _setTimeout = setTimeout;
    _performance = performance;
    _Function = Function;
    functionProto = _Function.prototype;
    mapProto = _Map.prototype;
    _mapHas = mapProto.has;
    _mapGet = mapProto.get;
    _mapSet = mapProto.set;
    objectPrototype = _Object.prototype;
    _objectHasOwnProperty = objectPrototype.hasOwnProperty;
    _objectToString = objectPrototype.toString;
    UNKNOWN = "<unknown>";
    VERSION = "1.0.0-rc.26";
    FLAG = "_ANYA_";
    MAX_QUEUE_SIZE = 1e4;
    FLUSH_TIMEOUT = false ? 5e3 : 1e3;
    SESSION_EXPIRE_TIMEOUT = FLUSH_TIMEOUT * 60;
    GZIP_MIN_LEN = 1e3;
    ENDPOINT = "https://lint.million.dev/api/v1/ingest";
    REACT_PREFIX = "Symbol(react.";
    ELEMENT_SYMBOL_STRING = REACT_PREFIX + "element)";
    FORWARD_REF_SYMBOL_STRING = REACT_PREFIX + "forward_ref)";
    LAZY_SYMBOL_STRING = REACT_PREFIX + "lazy)";
    MEMO_SYMBOL_STRING = REACT_PREFIX + "memo)";
    FRAGMENT_SYMBOL_STRING = REACT_PREFIX + "fragment)";
    PORTAL_SYMBOL_STRING = REACT_PREFIX + "portal)";
    PROFILER_SYMBOL_STRING = REACT_PREFIX + "profiler)";
    STRICT_MODE_SYMBOL_STRING = REACT_PREFIX + "strict_mode)";
    SUSPENSE_SYMBOL_STRING = REACT_PREFIX + "suspense)";
    SUSPENSE_LIST_SYMBOL_STRING = REACT_PREFIX + "suspense_list)";
    MOBX_SYMBOL_STRING = "Symbol(mobx administration)";
    PROFILER_DISPLAY_NAME = "Million(Profiler)";
    VOID_ELEMENTS = [
      "area",
      "base",
      "br",
      "col",
      "embed",
      "hr",
      "img",
      "input",
      "keygen",
      "link",
      "menuitem",
      "meta",
      "param",
      "source",
      "track",
      "wbr"
    ];
  }
});

// ../../node_modules/.pnpm/@gaearon+lag-radar@0.1.0/node_modules/@gaearon/lag-radar/lag-radar.js
function lagRadar(config = {}) {
  const {
    frames = 50,
    // number of frames to draw, more = worse performance
    speed = 17e-4,
    // how fast the sweep moves (rads per ms)
    size = 300,
    // outer frame px
    inset = 3,
    // circle inset px
    parent = document.body
    // DOM node to attach to
  } = config;
  const svgns = "http://www.w3.org/2000/svg";
  const styles = document.createTextNode(`
    .lagRadar-sweep > * {
      shape-rendering: crispEdges;
    }
    .lagRadar-face {
      fill: transparent;
    }
    .lagRadar-hand {
      stroke-width: 4px;
      stroke-linecap: round;
    }
  `);
  function $svg(tag, props = {}, children = []) {
    const el = document.createElementNS(svgns, tag);
    Object.keys(props).forEach((prop) => el.setAttribute(prop, props[prop]));
    children.forEach((child) => el.appendChild(child));
    return el;
  }
  const PI2 = Math.PI * 2;
  const middle = size / 2;
  const radius = middle - inset;
  const $hand = $svg("path", { class: "lagRadar-hand" });
  const $arcs = new Array(frames).fill("path").map((t) => $svg(t));
  const $root = $svg("svg", { class: "lagRadar", height: size, width: size }, [
    $svg("style", { type: "text/css" }, [styles]),
    $svg("g", { class: "lagRadar-sweep" }, $arcs),
    $hand,
    $svg("circle", { class: "lagRadar-face", cx: middle, cy: middle, r: radius })
  ]);
  parent.appendChild($root);
  let frame;
  let framePtr = 0;
  let last = {
    rotation: 0,
    now: Date.now(),
    tx: middle + radius,
    ty: middle
  };
  const calcHue = (() => {
    const max_hue = 120;
    const max_ms = 1e3;
    const log_f = 10;
    const mult = max_hue / Math.log(max_ms / log_f);
    return function(ms_delta) {
      return max_hue - Math.max(0, Math.min(mult * Math.log(ms_delta / log_f), max_hue));
    };
  })();
  function animate() {
    const now = Date.now();
    const rdelta = Math.min(PI2 - speed, speed * (now - last.now));
    const rotation = (last.rotation + rdelta) % PI2;
    const tx = middle + radius * Math.cos(rotation);
    const ty = middle + radius * Math.sin(rotation);
    const bigArc = rdelta < Math.PI ? "0" : "1";
    const path = `M${tx} ${ty}A${radius} ${radius} 0 ${bigArc} 0 ${last.tx} ${last.ty}L${middle} ${middle}`;
    const hue = calcHue(rdelta / speed);
    $arcs[framePtr % frames].setAttribute("d", path);
    $arcs[framePtr % frames].setAttribute("fill", `hsl(${hue}, 80%, 40%)`);
    $hand.setAttribute("d", `M${middle} ${middle}L${tx} ${ty}`);
    $hand.setAttribute("stroke", `hsl(${hue}, 80%, 60%)`);
    for (let i = 0; i < frames; i++) {
      $arcs[(frames + framePtr - i) % frames].style.fillOpacity = 1 - i / frames;
    }
    framePtr++;
    last = { now, rotation, tx, ty };
    frame = window.requestAnimationFrame(animate);
  }
  animate();
  return function destroy() {
    if (frame) {
      window.cancelAnimationFrame(frame);
    }
    $root.remove();
  };
}
var init_lag_radar = __esm({
  "../../node_modules/.pnpm/@gaearon+lag-radar@0.1.0/node_modules/@gaearon/lag-radar/lag-radar.js"() {
    "use strict";
  }
});

// ../../node_modules/.pnpm/react-lag-radar@1.0.0_react@18.3.1/node_modules/react-lag-radar/Radar.js
import { useLayoutEffect as useLayoutEffect2, useRef as useRef2, createElement, memo } from "react";
var Radar_default;
var init_Radar = __esm({
  "../../node_modules/.pnpm/react-lag-radar@1.0.0_react@18.3.1/node_modules/react-lag-radar/Radar.js"() {
    "use strict";
    init_lag_radar();
    Radar_default = memo(function Radar(props) {
      let frames = props.frames || 20;
      let size = props.size || 100;
      let options = Object.assign({}, props, {
        frames,
        size
      });
      let ref = useRef2();
      useLayoutEffect2(() => {
        let destroy = lagRadar(Object.assign({}, options, {
          parent: ref.current
        }));
        return destroy;
      }, [options, ref]);
      return createElement("div", { ref });
    });
  }
});

// runtime/src/core/dev/use-ses-shim.js
import React2 from "react";
var require_use_ses_shim = __commonJS({
  "runtime/src/core/dev/use-ses-shim.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var ReactSharedInternals = React2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        function error(format) {
          {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format, args);
            }
          }
        }
        function printWarning(level, format, args) {
          {
            var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame.getStackAddendum();
            if (stack !== "") {
              format += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        function is(x, y) {
          return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
        }
        var objectIs = typeof Object.is === "function" ? Object.is : is;
        var useState3 = React2.useState, useEffect2 = React2.useEffect, useLayoutEffect3 = React2.useLayoutEffect, useDebugValue = React2.useDebugValue;
        var didWarnOld18Alpha = false;
        var didWarnUncachedGetSnapshot = false;
        function useSyncExternalStore2(subscribe, getSnapshot, getServerSnapshot) {
          {
            if (!didWarnOld18Alpha) {
              if (React2.startTransition !== void 0) {
                didWarnOld18Alpha = true;
                error(
                  "You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."
                );
              }
            }
          }
          var value = getSnapshot();
          {
            if (!didWarnUncachedGetSnapshot) {
              var cachedValue = getSnapshot();
              if (!objectIs(value, cachedValue)) {
                error(
                  "The result of getSnapshot should be cached to avoid an infinite loop"
                );
                didWarnUncachedGetSnapshot = true;
              }
            }
          }
          var _useState = useState3({
            inst: {
              value,
              getSnapshot
            }
          }), inst = _useState[0].inst, forceUpdate = _useState[1];
          useLayoutEffect3(
            function() {
              inst.value = value;
              inst.getSnapshot = getSnapshot;
              if (checkIfSnapshotChanged(inst)) {
                forceUpdate({
                  inst
                });
              }
            },
            [subscribe, value, getSnapshot]
          );
          useEffect2(
            function() {
              if (checkIfSnapshotChanged(inst)) {
                forceUpdate({
                  inst
                });
              }
              var handleStoreChange = function() {
                if (checkIfSnapshotChanged(inst)) {
                  forceUpdate({
                    inst
                  });
                }
              };
              return subscribe(handleStoreChange);
            },
            [subscribe]
          );
          useDebugValue(value);
          return value;
        }
        function checkIfSnapshotChanged(inst) {
          var latestGetSnapshot = inst.getSnapshot;
          var prevValue = inst.value;
          try {
            var nextValue = latestGetSnapshot();
            return !objectIs(prevValue, nextValue);
          } catch (error2) {
            return true;
          }
        }
        function useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {
          return getSnapshot();
        }
        var canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
        var isServerEnvironment = !canUseDOM;
        var shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore2;
        var useSyncExternalStore$2 = React2.useSyncExternalStore !== void 0 ? React2.useSyncExternalStore : shim;
        exports.useSyncExternalStore = useSyncExternalStore$2;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  }
});

// runtime/src/core/dev/toolbar.tsx
var toolbar_exports = {};
__export(toolbar_exports, {
  default: () => toolbar_default
});
import React3 from "react";
var import_use_ses_shim, prettyBytes, withTimeout, toolbar_default;
var init_toolbar = __esm({
  "runtime/src/core/dev/toolbar.tsx"() {
    "use strict";
    init_Radar();
    init_constants();
    import_use_ses_shim = __toESM(require_use_ses_shim());
    prettyBytes = (number) => {
      const BYTE_UNITS = ["B", "kB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"];
      if (number < 1) {
        const numberString2 = number.toLocaleString("en-US");
        return numberString2 + BYTE_UNITS[0];
      }
      const exponent = Math.min(
        Math.floor(Math.log(number) / Math.log(1024)),
        BYTE_UNITS.length - 1
      );
      number /= 1024 ** exponent;
      const result = number.toPrecision(3);
      const numberString = Number(result).toLocaleString("en-US");
      const unit = BYTE_UNITS[exponent];
      return numberString + unit;
    };
    withTimeout = (promise, timeout) => {
      return Promise.race([
        promise,
        new Promise((_, reject) => {
          setTimeout(() => reject(new Error("Timeout")), timeout);
        })
      ]);
    };
    toolbar_default = async () => {
      const DEV = _window[`${FLAG}DEV_`];
      const toolbarStore = {
        listeners: [],
        batch: [],
        data: {
          bytes: 0,
          items: 0,
          pending: false,
          state: "hidden"
        },
        pushBatch: (batch2) => {
          toolbarStore.batch.push(...batch2);
          toolbarStore.emit();
        },
        setData(data) {
          toolbarStore.data = {
            ...toolbarStore.data,
            ...data
          };
          toolbarStore.emit();
        },
        subscribe(listener) {
          toolbarStore.listeners.push(listener);
          return () => {
            toolbarStore.listeners = toolbarStore.listeners.filter(
              (l) => l !== listener
            );
          };
        },
        getSnapshot() {
          return toolbarStore.data;
        },
        emit() {
          for (const listener of toolbarStore.listeners) {
            listener();
          }
        },
        healthCheck: async () => {
          if (toolbarStore.data.state === "dormant")
            return;
          try {
            withTimeout(
              fetch(`${DEV.url}/healthcheck`, {
                headers: { "X-Session-Id": DEV.proxySessionId }
              }),
              1e4
            ).then((req) => req.json()).then((data) => {
              if (!data.ok) {
                if (toolbarStore.data.state === "error")
                  return;
                toolbarStore.setData({
                  state: "error",
                  error: "Failed to connect to VSCode",
                  cause: "!data.ok"
                });
                return;
              }
              toolbarStore.setData({
                state: "data",
                error: void 0,
                sessions: data.sessions
              });
            }).catch(() => {
              if (["dormant", "error"].includes(toolbarStore.data.state))
                return;
              toolbarStore.setData({
                state: "error",
                error: `Failed to ingest events`,
                cause: ".catch()"
              });
            });
          } catch (e) {
            toolbarStore.setData({
              state: "error",
              error: `Failed to ingest events (ERR)`,
              cause: `try-catch ${e?.message}`
            });
          }
        }
      };
      DEV.toolbarStore = toolbarStore;
      const App = () => {
        const prevItems = React3.useRef(0);
        const data = (0, import_use_ses_shim.useSyncExternalStore)(
          toolbarStore.subscribe,
          toolbarStore.getSnapshot
        );
        if (data.state === "connecting" || data.state === "hidden") {
          return /* @__PURE__ */ React3.createElement(
            "div",
            {
              className: `toolbar connecting ${data.state === "hidden" ? "hidden" : ""}`,
              onClick: () => {
                toolbarStore.setData({
                  state: "dormant"
                });
              }
            },
            /* @__PURE__ */ React3.createElement(
              "svg",
              {
                className: "animate-spin spinner",
                xmlns: "http://www.w3.org/2000/svg",
                fill: "none",
                viewBox: "0 0 24 24"
              },
              /* @__PURE__ */ React3.createElement(
                "circle",
                {
                  style: { opacity: 0.25 },
                  cx: "12",
                  cy: "12",
                  r: "10",
                  stroke: "currentColor",
                  strokeWidth: "4"
                }
              ),
              /* @__PURE__ */ React3.createElement(
                "path",
                {
                  style: { opacity: 0.75 },
                  fill: "currentColor",
                  d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                }
              )
            ),
            "Connecting..."
          );
        }
        if (data.state === "dormant") {
          return /* @__PURE__ */ React3.createElement(
            "div",
            {
              className: "toolbar dormant",
              onClick: () => {
                toolbarStore.setData({
                  state: "connecting"
                });
              }
            },
            "\u{1F440}"
          );
        }
        if (data.state === "error") {
          return /* @__PURE__ */ React3.createElement("div", { className: "toolbar error" }, /* @__PURE__ */ React3.createElement(
            "div",
            {
              style: {
                position: "relative",
                display: "flex",
                alignItems: "center"
              }
            },
            /* @__PURE__ */ React3.createElement(
              "div",
              {
                style: { position: "absolute" },
                className: "animate-ping error-circle"
              }
            ),
            /* @__PURE__ */ React3.createElement("div", { className: "error-circle" })
          ), /* @__PURE__ */ React3.createElement(
            "a",
            {
              href: `https://github.com/aidenybai/million/issues/new?title=${encodeURIComponent(data.error)}&body=${encodeURIComponent(
                `# ${data.error} ${data.cause}

Machine ID: \`${DEV.id}\`

> [!NOTE]
> [Book a call](https://cal.com/aiden)

| key | value |
| --- | ----- |
${Object.entries(
                  {
                    ...DEV.session,
                    url: window.location.href,
                    time: Date.now(),
                    items: toolbarStore.data.items,
                    bytes: toolbarStore.data.bytes
                  }
                ).map(([key, value]) => `| ${key} | ${String(value)} |`).join("\n")}

${(DEV.toolbarStore.data.sessions || []).map(
                  (session2) => `- ${session2.id} (${session2.host}:${session2.port} - ${session2.match})`
                ).join("\n")}`
              )}&labels=bug,million-lint`,
              target: "_blank"
            },
            "Call us for help! "
          ), /* @__PURE__ */ React3.createElement("div", { className: "div" }), " ", /* @__PURE__ */ React3.createElement(
            "div",
            {
              onClick: () => {
                toolbarStore.setData({
                  state: "dormant"
                });
              }
            },
            data.error
          ));
        }
        const { items, bytes, pending } = toolbarStore.data;
        const dirty = prevItems.current !== items;
        if (dirty) {
          prevItems.current = items;
        }
        return /* @__PURE__ */ React3.createElement(
          "div",
          {
            className: `toolbar data ${dirty ? "ping-once" : ""}`,
            onClick: () => {
              toolbarStore.setData({
                state: "dormant"
              });
            }
          },
          /* @__PURE__ */ React3.createElement("span", { className: pending || !items ? "pulse" : "" }, items ? `\xD7${items} (${prettyBytes(bytes)})` : "Interact with the page to start"),
          /* @__PURE__ */ React3.createElement(Radar_default, { frames: 30, speed: 17e-4, size: 20, inset: 3 })
        );
      };
      const render = async (node) => {
        const elementName = "million-dev-toolbar";
        const root = _document.createElement(elementName);
        root.attachShadow({ mode: "open" });
        const style = _document.createElement("style");
        style.innerHTML = `
      .toolbar {
        position: fixed;
        bottom: 10px;
        right: 10px;
        z-index: 1000;
        opacity: 0;
        display: flex;
        height: 22px;
        justify-content: center;
        align-items: center;
        gap: 3px;
        border-radius: 50px;
        padding: 4px 12px;
        background-color: #111;
        color: #fff;
        font-size: 12px;
        font-variant-numeric: tabular-nums;
        transition: opacity 0.2s ease-in-out, bottom 0.2s ease-in-out;
        border: 1px solid #ffffff2e;
        box-shadow: 0 25px 50px -12px rgb(0 0 0 / 0.25);
      }

      .hidden {
        pointer-events: none;
        opacity: 0;
      }

      .spinner {
        height: 0.85rem;
        width: 0.85rem;
        color: white;
      }

      .error {
        background: #440c13;
        animation: none;
        color: #ff575e;
        opacity: 1;
        align-items: center;
        gap: 6px;
        border: 1px solid #ff575e2e;
      }

      .error a {
        color: #ff575e;
        font-weight: bold;
        text-decoration: underline dotted;
      }

      .error a:hover {
        text-decoration: underline;
      }

      .error .div {
        height: 100%;
        width: 1px;
        background-color: #ff575e2e;
      }

      .connecting {
        display: flex;
        gap: 6px;
        font-weight: normal;
        animation: pulse 2s cubic-bezier(.4,0,.6,1) infinite;
      }

      .pulse {
        animation: pulse 2s cubic-bezier(.4,0,.6,1) infinite;
      }

      .dormant {
        bottom: -15px;
        opacity: 0.5;
      }

      .dormant:hover {
        opacity: 1;
      }

      .data {
        opacity: 1;
      }

      .error-circle {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background-color: #ff575e;
      }

      @keyframes pulse {
        0%, 100% {
          opacity: 1;
        }
        50% {
          opacity: .5;
        }
      }

      .animate-spin {
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        from {
          transform: rotate(0deg);
        }
        to {
          transform: rotate(360deg);
        }
      }

      .animate-ping {
        animation: ping 1s cubic-bezier(0, 0, 0.2, 1) infinite;
      }

      @keyframes ping {
        75%, 100% {
          transform: scale(2);
          opacity: 0;
        }
      }

      .ping-once {
        animation: subtle-ping 0.3s ease-in-out;
      }

      @keyframes subtle-ping {
        10% {
          filter: brightness(3);
        }
        100% {
          filter: brightness(1);
        }
      }
    `;
        root.shadowRoot.appendChild(style);
        const prevMountedElement = _document.querySelector(elementName);
        if (prevMountedElement) {
          if (root._interval) {
            clearInterval(root._interval);
          }
          prevMountedElement.replaceWith(root);
        } else {
          document.body.appendChild(root);
        }
        root._interval = setInterval(() => {
          DEV.toolbarStore.healthCheck();
        }, FLUSH_TIMEOUT);
        const majorVersion = Number(React3.version.split(".")[0]);
        if (majorVersion >= 18) {
          const ReactDOMClient = (await import("react-dom/client")).default;
          ReactDOMClient.createRoot(root.shadowRoot).render(node);
        } else {
          const ReactDOM = (await import("react-dom")).default;
          ReactDOM.render(node, root.shadowRoot);
        }
      };
      await render(React3.createElement(App));
    };
  }
});

// runtime/src/core/index.ts
import * as React4 from "react";

// runtime/src/core/session.ts
init_constants();

// runtime/src/core/utils/helpers.ts
init_constants();
var debounce = (callback, timeout = 1e3) => {
  let timeoutId;
  return function() {
    if (timeoutId != _null) {
      clearTimeout(timeoutId);
    }
    timeoutId = _setTimeout(() => {
      callback.apply(null, arguments);
      timeoutId = void 0;
    }, timeout);
  };
};
var onIdle = (callback) => {
  if ("scheduler" in globalThis) {
    return _window.scheduler.postTask(callback, { priority: "background" });
  }
  if ("requestIdleCallback" in _window) {
    return requestIdleCallback(callback);
  }
  return _setTimeout(callback, 0);
};
var onHidden = (callback) => {
  const handler = (event) => {
    if (event.type === "pagehide" || document.visibilityState === "hidden") {
      callback();
    }
  };
  addEventListener("visibilitychange", handler, true);
  addEventListener("pagehide", handler, true);
};
var generateId = () => {
  return Math.random().toString(36).substring(2) + Date.now();
};
var getRenderBatchIndexKey = (key, kind, loc, owner2, error) => {
  return (
    // eslint-disable-next-line prefer-template
    key + "." + kind + "." + loc + "." + (owner2 || "") + "." + (error || "")
  );
};

// runtime/src/core/session.ts
var getGpuRenderer = () => {
  if (!("chrome" in _window))
    return "";
  const gl = document.createElement("canvas").getContext("webgl", { powerPreference: "high-performance" });
  if (!gl)
    return "";
  const ext = gl.getExtension("WEBGL_debug_renderer_info");
  return ext ? gl.getParameter(ext.UNMASKED_RENDERER_WEBGL) : "";
};
var getSession = () => {
  if (isSSR)
    return _null;
  const id = generateId();
  const url2 = _window.location.toString();
  const wifi = navigator.connection?.effectiveType || UNKNOWN;
  const cpu = navigator.hardwareConcurrency;
  const mem = navigator.deviceMemory;
  const session2 = {
    id,
    url: url2,
    wifi,
    cpu,
    mem,
    gpu: UNKNOWN
  };
  onIdle(() => {
    session2.gpu = getGpuRenderer();
  });
  return session2;
};

// runtime/src/core/transport.ts
init_constants();
var contentType = "application/json";
var supportsCompression = typeof CompressionStream === "function";
var compress = async (payload) => {
  const stream = new Blob([payload], { type: contentType }).stream().pipeThrough(new CompressionStream("gzip"));
  return new Response(stream).arrayBuffer();
};
var transport = async (url2, payload, proxySessionId2) => {
  const fail = { ok: false };
  if (isSSR)
    return fail;
  const json = JSON.stringify(payload, (key, value) => {
    if (
      // eslint-disable-next-line eqeqeq
      value != null && value !== false && // eslint-disable-next-line @typescript-eslint/prefer-string-starts-ends-with
      key[0] !== "_"
    ) {
      return value;
    }
  });
  const shouldCompress = json.length > GZIP_MIN_LEN;
  const body = shouldCompress && supportsCompression ? await compress(json) : json;
  let prod;
  if (prod = false) {
    if (!navigator.onLine)
      return fail;
  }
  const headers = {
    "Content-Type": contentType,
    "Content-Encoding": shouldCompress ? "gzip" : void 0
  };
  if (shouldCompress)
    url2 += "?z=1";
  if (navigator.sendBeacon && prod) {
    navigator.sendBeacon(url2, body);
    return { ok: true };
  }
  if (proxySessionId2) {
    headers["X-Session-Id"] = proxySessionId2;
  }
  return fetch(url2, {
    body,
    method: "POST",
    // make sure payload actually gets thru
    keepalive: true,
    priority: "low",
    mode: proxySessionId2 || prod ? void 0 : "no-cors",
    headers
  });
};

// runtime/src/core/index.ts
init_constants();

// runtime/src/core/utils/react-internals.ts
init_constants();
import * as React from "react";
function useFiber() {
  const fiber = React.useRef();
  React.useState(() => {
    const bind = functionProto.bind;
    functionProto.bind = function(self2, maybeFiber) {
      if (self2 === _null && typeof maybeFiber?.type === "function") {
        fiber.current = maybeFiber;
        functionProto.bind = bind;
      }
      return bind.apply(this, arguments);
    };
  });
  return fiber.current;
}
var traverseFiber = (fiber, ascending, selector) => {
  if (!fiber)
    return _null;
  if (selector(fiber) === true)
    return fiber;
  let child = ascending ? fiber.return : fiber.child;
  while (child) {
    const match = traverseFiber(child, ascending, selector);
    if (match)
      return match;
    child = ascending ? null : child.sibling;
  }
  return _null;
};
var useNearestChild = (fiber) => {
  const childRef = React.useRef();
  React.useLayoutEffect(() => {
    childRef.current = traverseFiber(
      fiber,
      false,
      (node) => typeof node.type === "string"
    )?.stateNode;
  }, [fiber]);
  return childRef;
};
var didFiberRender = (fiber) => {
  if (!fiber?.alternate)
    return true;
  const { alternate } = fiber;
  return alternate.memoizedProps !== fiber.memoizedProps || alternate.memoizedState !== fiber.memoizedState || alternate.ref !== fiber.ref;
};
var getTimings = (fiber) => {
  const totalTime = fiber?.actualDuration ?? 0;
  let selfTime = totalTime;
  let child = fiber?.child;
  while (totalTime > 0 && child != _null) {
    selfTime -= child?.actualDuration || 0;
    child = child.sibling;
  }
  return {
    /**
     * totalTime
     */
    t: totalTime,
    /**
     * selfTime
     */
    s: selfTime
  };
};
var owner = _null;
var getCurrentOwner = (fiber) => {
  let currentOwner = owner;
  if (!fiber) {
    currentOwner = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED?.ReactCurrentOwner.current;
  }
  if (currentOwner)
    owner = currentOwner;
  return owner;
};
var getParentOwner = (fiber) => {
  const type = getCurrentOwner(fiber)?._debugOwner?.type;
  if (!type || typeof type !== "function")
    return _null;
  return type[FLAG] || _null;
};
var truncateString = (value, length) => {
  return value.length > length ? value.slice(0, length) + "\u2026" : value;
};
var serialize = (value) => {
  switch (typeof value) {
    case "function":
      return truncateString(value.toString(), 20);
    case "string":
      return truncateString(value, 20);
    case "object":
      if (value === _null) {
        return "null";
      }
      if (_Array.isArray(value)) {
        return value.length > 0 ? "[\u2026]" : "[]";
      }
      if (typeof value.$$typeof === "symbol" && String(value.$$typeof) === ELEMENT_SYMBOL_STRING) {
        return (
          // eslint-disable-next-line prefer-template
          "<" + (value.type.displayName || value.type.name || "") + (_Object.keys(value.props).length > 0 ? " \u2026" : "") + ">"
        );
      }
      if (typeof value === "object" && value !== _null && value.constructor === _Object) {
        for (const key in value) {
          if (_objectHasOwnProperty.call(value, key)) {
            return "{\u2026}";
          }
        }
        return "{}";
      }
      const tagString = _objectToString.call(value).slice(8, -1);
      if (tagString === "Object") {
        const constructor = _Object.getPrototypeOf(value)?.constructor;
        if (typeof constructor === "function") {
          return (constructor.displayName || constructor.name || "") + "{\u2026}";
        }
      }
      return tagString + "{\u2026}";
    default:
      return String(value);
  }
};
var getFunctionFromJSX = (element, isStyledComponent = false) => {
  if (typeof element === "function")
    return element;
  if (typeof element !== "object")
    return _null;
  const type = isStyledComponent ? element.type.target : element.type;
  if (typeof type === "function")
    return type;
  if (typeof type !== "object")
    return _null;
  if ("$$typeof" in type) {
    switch (String(type.$$typeof)) {
      case FORWARD_REF_SYMBOL_STRING:
        return getFunctionFromJSX(element.type.render, false);
      case MEMO_SYMBOL_STRING:
      case LAZY_SYMBOL_STRING:
        return getFunctionFromJSX(element.type, false);
    }
  }
  return _null;
};
var setRef = (ref, value) => {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref !== null && ref !== void 0) {
    ref.current = value;
  }
};
var mergeProps = (nextProps, prevProps) => {
  const overrideProps = _Object.assign({}, nextProps);
  for (const propName in nextProps) {
    const nextPropValue = nextProps[propName];
    const prevPropValue = prevProps[propName];
    if (propName.startsWith("on")) {
      if (nextPropValue && prevPropValue) {
        overrideProps[propName] = function() {
          prevPropValue.apply(this, arguments);
          nextPropValue.apply(this, arguments);
        };
      } else if (nextPropValue) {
        overrideProps[propName] = nextPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = _Object.assign(
        {},
        prevPropValue,
        nextPropValue
      );
    } else if (propName === "className") {
      overrideProps[propName] = [nextPropValue, prevPropValue].filter(Boolean).join(" ");
    }
  }
  return _Object.assign({}, prevProps, overrideProps);
};
var types = [
  STRICT_MODE_SYMBOL_STRING,
  FRAGMENT_SYMBOL_STRING,
  PROFILER_SYMBOL_STRING,
  SUSPENSE_SYMBOL_STRING,
  SUSPENSE_LIST_SYMBOL_STRING
];
var isSpecialElement = (element) => {
  return (
    // is class
    typeof element.type === "function" && element.type.prototype?.isReactComponent || String(element.$$typeof) === PORTAL_SYMBOL_STRING || types.includes(String(element.type)) || // some components for @mui/material
    element.render?.muiName
  );
};
var isMobXLoaded = Symbol.for("mobx administration");
var isMobXStore = (value) => {
  if (!isMobXLoaded || !value || typeof value !== "object") {
    return false;
  }
  const symbol = _Object.getOwnPropertySymbols(value)[0];
  return String(symbol) === MOBX_SYMBOL_STRING;
};

// runtime/src/core/index.ts
var IS_REACT_19 = React4.version.startsWith("19");
var batchIndexLookup = /* @__PURE__ */ new _Map();
var metadataLookup = /* @__PURE__ */ new _Map();
var batch = [];
var inited = false;
var session = /* @__PURE__ */ getSession();
var url = _null;
var apiKey;
var buildId;
var onRender = _null;
var events = [];
var currentId = _null;
var currentIndex = -1;
var proxySessionId;
var getMetadata = (key) => {
  return _mapGet.call(metadataLookup, key);
};
var UNSTABLE_TYPES = ["object", "function"];
var getChange = (prevValue, nextValue) => {
  if (_Object.is(prevValue, nextValue))
    return _null;
  const prev = serialize(prevValue);
  const next = serialize(nextValue);
  const type = nextValue ? typeof nextValue : typeof prevValue;
  const unstable = prev === next && UNSTABLE_TYPES.includes(type);
  return {
    // unstable
    u: unstable,
    // type
    t: type,
    // count
    c: 1,
    // index: (if it's a change of the deps array, this will be the index of the dep)
    i: _null,
    // name: used to help identify the change
    // prop change postfixes this with the name of the prop
    // âŸ = "unit seperator symbol"
    // eslint-disable-next-line prefer-template
    n: prev === next ? prev : prev + "~" + next,
    d: _null
  };
};
var captureClass = (key, setState, loc, index, noisy, cache) => {
  return function() {
    const value = arguments[0];
    const fiber = useFiber();
    if (noisy)
      return value;
    const owner2 = getParentOwner(fiber);
    const prevValue = cache?.[index];
    setState.apply(this, arguments);
    const change = getChange(prevValue, value);
    if (change) {
      reportRender(
        // key: encode(filename).encoded(componentName)
        // (e.g. "/some/file/path/index.jsx.App")
        key,
        4 /* Value */,
        // CaptureKind
        // loc: encode(SourceLocation)
        // e.g. `this.setState(newVal)` -> encode([1, 2, 3, 4])
        loc,
        _null,
        // secondaryLoc
        _null,
        // locs
        0,
        // selfTime
        0,
        // totalTime
        1,
        // count
        _null,
        // self
        owner2,
        // owner
        _null,
        // message
        [change]
        // changes
      );
      if (cache)
        cache[index] = value;
    }
    return value;
  };
};
var captureDeps = (key, deps, loc, locs, index, noisy, cache) => {
  if (!_isArray(deps))
    return deps;
  const fiber = useFiber();
  if (noisy)
    return deps;
  const owner2 = getParentOwner(fiber);
  const prev = cache?.[index];
  const changes = [];
  if (prev) {
    for (let i = 0, len = deps.length; i < len; i++) {
      const prevDepValue = prev[i];
      const nextDepValue = deps[i];
      const change = getChange(prevDepValue, nextDepValue);
      if (!change)
        continue;
      change.n = `${i}`;
      changes.push(change);
    }
  }
  if (!prev || changes.length) {
    reportRender(
      // key: encode(filename).encoded(componentName)
      // (e.g. "/some/file/path/index.jsx.App")
      key,
      1 /* Deps */,
      // CaptureKind
      // loc: encode(SourceLocation)
      // e.g. `[foo, bar, baz]` -> encode([1, 2, 3, 4])
      loc,
      _null,
      // secondaryLoc
      // locs: encode([Dep1SourceLocation, Dep2SourceLocation, ...])
      // e.g. `[foo, bar, baz]` -> encode([[1, 2, 3, 4], [5, 6, 7, 8], ...])
      locs,
      0,
      // selfTime
      0,
      // totalTime
      1,
      // count
      _null,
      // self
      owner2,
      // owner
      _null,
      // message
      changes
      // changes
    );
  }
  if (cache)
    cache[index] = deps;
  return deps;
};
var captureProps = (key, props, loc, index, noisy, cache) => {
  if (typeof props !== "object")
    return props;
  const fiber = useFiber();
  const owner2 = getParentOwner(fiber);
  if (noisy)
    return props;
  const prev = cache?.[index];
  if (didFiberRender(fiber)) {
    const changes = [];
    if (prev) {
      for (const name in props) {
        const change = getChange(prev[name], props[name]);
        if (!change)
          continue;
        change.n = name;
        changes.push(change);
      }
    }
    if (!prev || changes.length) {
      reportRender(
        // key: encode(filename).encoded(componentName)
        // e.g. "/some/file/path/index.jsx.App"
        key,
        2 /* Props */,
        // CaptureKind
        loc,
        // loc: encode(SourceLocation)
        _null,
        // secondaryLoc
        _null,
        // locs
        0,
        // selfTime
        0,
        // totalTime
        1,
        // count
        _null,
        // self
        owner2,
        // owner
        _null,
        // message
        changes
        // changes
      );
    }
  }
  if (!prev) {
    for (const name in props) {
      if (name === "children")
        continue;
      if (isMobXStore(props[name])) {
        reportRender(
          // key: encode(filename).encoded(componentName)
          // e.g. "/some/file/path/index.jsx.App"
          key,
          // JSXMount = 'mount' | 'unmount'
          // JSXUpdate = 'update'
          1024 /* Note */,
          // CaptureKind
          // loc = scoped source location of the JSX element,
          // or the location of the JSX element
          loc,
          _null,
          // secondaryLoc = location of the JSX element
          _null,
          // locs
          0,
          // selfTime
          0,
          // totalTime
          0,
          // count
          _null,
          // self
          owner2,
          // owner
          "mobx store",
          // message
          []
          // changes
        );
      }
    }
  }
  if (cache)
    cache[index] = props;
  return props;
};
var captureValue = (key, value, loc, index, noisy, cache) => {
  const fiber = useFiber();
  if (noisy)
    return value;
  const owner2 = getParentOwner(fiber);
  if (fiber && _isArray(value) && value.length === 2 && typeof value[1] === "function") {
    const dispatcher = value[1];
    if (cache) {
      if (!cache[index]) {
        reportRender(
          // key: encode(filename).encoded(componentName)
          // e.g. "/some/file/path/index.jsx.App"
          key,
          4 /* Value */,
          // CaptureKind
          loc,
          // loc: encode(SourceLocation)
          _null,
          // secondaryLoc
          _null,
          // locs
          0,
          // selfTime
          0,
          // totalTime
          1,
          // count
          _null,
          // self
          owner2,
          // owner
          _null,
          // message
          []
          // changes
        );
      }
      cache[index] = value[0];
    }
    value[1] = function(nextValue) {
      const prevValue2 = value[0];
      dispatcher(nextValue);
      const change = getChange(prevValue2, nextValue);
      if (!change || !didFiberRender(fiber))
        return;
      const {
        s,
        t
        /* totalTime */
      } = getTimings(fiber);
      reportRender(
        // key: encode(filename).encoded(componentName)
        // e.g. "/some/file/path/index.jsx.App"
        key,
        4 /* Value */,
        // CaptureKind
        loc,
        // loc: encode(SourceLocation)
        _null,
        // secondaryLoc
        _null,
        // locs
        s,
        // selfTime
        t,
        // totalTime
        1,
        // count
        _null,
        // self
        owner2,
        // owner
        _null,
        // message
        [change]
        // changes
      );
    };
    return value;
  }
  let targetValue = value;
  if (fiber && typeof value === "object" && value?.current) {
    targetValue = value.current;
  }
  const prevValue = cache?.[index];
  if (didFiberRender(fiber)) {
    const change = getChange(prevValue, targetValue);
    if (!change)
      return value;
    reportRender(
      // key: encode(filename).encoded(componentName)
      // e.g. "/some/file/path/index.jsx.App"
      key,
      // CaptureKind
      4 /* Value */,
      // loc: encode(SourceLocation)
      loc,
      // loc: encode(SourceLocation)
      _null,
      // secondaryLoc
      _null,
      // locs
      0,
      // selfTime
      0,
      // totalTime
      1,
      // count
      _null,
      // self
      owner2,
      // owner
      _null,
      // message
      [change]
      // changes
    );
  }
  if (cache)
    cache[index] = targetValue;
  return value;
};
var captureFunction = (key, fn, loc, noisy) => {
  if (typeof fn !== "function" || FLAG in fn || noisy)
    return fn;
  const capturedFn = function() {
    const startTime = _performance.now();
    try {
      const maybeEvent = arguments[0];
      if (maybeEvent && typeof maybeEvent === "object" && maybeEvent.currentTarget && typeof maybeEvent.currentTarget === "object") {
        maybeEvent.currentTarget[FLAG] = key + "." + loc;
      }
      const ret = fn.apply(this, arguments);
      const time = _performance.now() - startTime;
      reportRender(
        // key: encode(filename).encoded(componentName)
        // e.g. "/some/file/path/index.jsx.App"
        key,
        128 /* Function */,
        loc,
        // loc
        null,
        // secondaryLoc
        _null,
        // locs
        time,
        // selfTime
        time,
        // totalTime
        1,
        // count
        null,
        // self
        null,
        // owner
        null,
        // message
        []
        // changes
      );
      return ret;
    } catch (error) {
      reportRender(
        // key: encode(filename).encoded(componentName)
        // e.g. "/some/file/path/index.jsx.App"
        key,
        256 /* Error */,
        loc,
        // loc
        null,
        // secondaryLoc
        _null,
        // locs
        0,
        // selfTime
        0,
        // totalTime
        1,
        // count
        null,
        // self
        null,
        // owner
        error.message.trim(),
        // message
        []
        // changes
      );
      throw error;
    }
  };
  capturedFn[FLAG] = true;
  return capturedFn;
};
var Slot = /* @__PURE__ */ React4.forwardRef(
  (props, forwardedRef) => {
    const element = props._l;
    if (!element)
      return element;
    if (React4.isValidElement(element)) {
      if (typeof element.type === "string" && VOID_ELEMENTS.includes(element.type)) {
        return element;
      }
      const originalRef = IS_REACT_19 ? element.props.ref : element.ref;
      let ref = originalRef;
      if (forwardedRef) {
        ref = (value) => {
          setRef(originalRef, value);
          setRef(forwardedRef, value);
        };
      }
      const newProps = _Object.assign(
        mergeProps(element.props, props),
        {
          ref
        }
      );
      newProps._l = void 0;
      newProps._c = void 0;
      newProps._p = void 0;
      return /* @__PURE__ */ React4.cloneElement(
        props._p,
        _null,
        React4.cloneElement(
          element,
          newProps,
          props._c || props.children || element.props?.children
        )
      );
    }
    return element;
  }
);
Slot.displayName = PROFILER_DISPLAY_NAME;
var Profiler2 = React4.Profiler;
var renderInnerProfiler = (element, id, timeQueue) => {
  if (element.type.displayName === PROFILER_DISPLAY_NAME)
    return element;
  const profiler = React4.createElement(Profiler2, {
    id,
    onRender: (_id, _phase, totalTime) => {
      timeQueue.push(totalTime);
    },
    suppressHydrationWarning: true,
    children: element
  });
  if (String(element.type?.$$typeof) !== FORWARD_REF_SYMBOL_STRING) {
    return profiler;
  }
  return /* @__PURE__ */ React4.createElement(Slot, {
    _l: element,
    _c: void 0,
    _p: profiler
  });
};
var captureJSX = (key, element, loc, secondaryLoc, index, profilerType, noisy, cache) => {
  if (isSpecialElement(element) || noisy)
    return element;
  let isStyledComponent = false;
  if (typeof element.type === "object" && element.type?.componentStyle) {
    isStyledComponent = true;
    if (typeof element.type?.target === "string")
      return element;
  }
  const reference = getFunctionFromJSX(element, isStyledComponent);
  const self2 = reference?.[FLAG];
  const owner2 = getParentOwner(_null);
  let changes = [];
  const props = element.props;
  if (reference?.name === "observerComponent") {
    reportRender(
      // key: encode(filename).encoded(componentName)
      // e.g. "/some/file/path/index.jsx.App"
      key,
      // JSXMount = 'mount' | 'unmount'
      // JSXUpdate = 'update'
      1024 /* Note */,
      // CaptureKind
      // loc = scoped source location of the JSX element,
      // or the location of the JSX element
      loc,
      secondaryLoc,
      // secondaryLoc = location of the JSX element
      _null,
      // locs
      0,
      // selfTime
      0,
      // totalTime
      0,
      // count
      self2,
      // self
      owner2,
      // owner
      "mobx observer",
      // message
      changes
      // changes
    );
  }
  const prev = cache?.[index];
  if (prev) {
    for (const name in props) {
      if (name === "children")
        continue;
      const change = getChange(prev[name], props[name]);
      if (!change)
        continue;
      change.n = name;
      changes.push(change);
    }
  }
  if (cache)
    cache[index] = props;
  const timeQueue = [];
  const children = element.props.children;
  const existingKey = element.key || void 0;
  const hasProfilerType = profilerType != _null;
  const outerProfiler = React4.createElement(Profiler2, {
    id: key,
    key: existingKey,
    onRender: (_id, phase, totalTime) => {
      if (phase === "nested-update")
        return;
      const currentTime = timeQueue.shift() || 0;
      reportRender(
        // key: encode(filename).encoded(componentName)
        // e.g. "/some/file/path/index.jsx.App"
        key,
        // JSXMount = 'mount' | 'unmount'
        // JSXUpdate = 'update'
        phase === "update" ? 64 /* JSXUpdate */ : 32 /* JSXMount */,
        // loc = scoped source location of the JSX element,
        // or the location of the JSX element
        loc,
        secondaryLoc,
        // secondaryLoc = location of the JSX element
        _null,
        // locs
        currentTime <= totalTime ? totalTime - currentTime : 0,
        // selfTime
        totalTime,
        // totalTime
        1,
        // count
        self2,
        // self
        owner2,
        // owner
        _null,
        // message
        changes
        // changes
      );
      changes = [];
    },
    suppressHydrationWarning: true,
    children: IS_REACT_19 ? element : hasProfilerType ? profilerType & 0 /* NoRef */ && children ? renderInnerProfiler(children, key, timeQueue) : element : _null
  });
  if (hasProfilerType || IS_REACT_19) {
    return outerProfiler;
  }
  return /* @__PURE__ */ React4.createElement(Slot, {
    key: existingKey,
    _l: element,
    _c: React4.isValidElement(children) ? renderInnerProfiler(children, key, timeQueue) : children,
    _p: outerProfiler
  });
};
var componentIds = /* @__PURE__ */ new WeakMap();
var captureMount = (key, data, loc) => {
  let noisy = false;
  const fiber = useFiber();
  const child = useNearestChild(fiber);
  if (fiber?.updateQueue?.memoCache) {
    data.$ = true;
  }
  const current = child?.current;
  if (current && !(FLAG in current)) {
    current[FLAG] = key;
  }
  if (true) {
    const ref = React4.useRef(_null);
    if (ref.current === _null) {
      const owner2 = getCurrentOwner(fiber);
      ref.current = true;
      if (owner2) {
        const prevMemoizedState = componentIds.get(owner2);
        if (!componentIds.has(owner2)) {
          componentIds.set(owner2, owner2.memoizedState);
        } else if (owner2.memoizedState !== prevMemoizedState) {
          componentIds.delete(owner2);
          noisy = true;
        }
      }
    }
  }
  const {
    s,
    t
    /* totalTime */
  } = getTimings(fiber);
  React4.useEffect(() => {
    if (didFiberRender(fiber) && !noisy) {
      reportRender(
        // key: encode(filename).encoded(componentName)
        // e.g. "/some/file/path/index.jsx.App"
        key,
        512 /* Baseline */,
        loc,
        // loc
        _null,
        // secondaryLoc
        _null,
        // locs
        s,
        // selfTime
        t,
        // totalTime
        1,
        // count
        _null,
        // self
        _null,
        // owner
        _null,
        // message
        []
        // changes
      );
    }
  });
  React4.useEffect(() => {
    noisy = false;
    data.i++;
    return () => {
      data.i--;
    };
  }, []);
  return {
    n: noisy,
    c: React4.useState(() => new _Array(data.c))[0]
  };
};
var $$ = (kind, key, value, loc, secondaryLoc, locs, index, profilerType, mountInfo) => {
  if (isSSR)
    return value;
  const data = getMetadata(key);
  if (!data)
    return value;
  const noisy = mountInfo?.n || false;
  const cache = mountInfo?.c || _null;
  if (kind & 512 /* Baseline */) {
    return captureMount(key, data, loc);
  } else if (kind & 2 /* Props */) {
    return captureProps(key, value, loc, index, noisy, cache);
  } else if (kind & 4 /* Value */) {
    return captureValue(key, value, loc, index, noisy, cache);
  } else if (kind & 1 /* Deps */) {
    return captureDeps(key, value, loc, locs, index, noisy, cache);
  } else if (kind & 16 /* JSX */) {
    return captureJSX(
      key,
      value,
      loc,
      secondaryLoc,
      index,
      profilerType,
      noisy,
      cache
    );
  } else if (kind & 128 /* Function */) {
    return captureFunction(key, value, loc, noisy);
  } else if (kind & 256 /* Error */) {
  } else if (kind & 0 /* ClassSetState */) {
    return captureClass(key, value, loc, index, noisy, cache);
  }
  return value;
};
var useCapture = (value, key, loc, index, mountInfo) => {
  if (!key || loc == _null || index == _null || value == _null || mountInfo == _null) {
    return value;
  }
  return $$(
    typeof value === "object" && "$$typeof" in value ? 16 /* JSX */ : 4 /* Value */,
    key,
    // key
    value,
    // value
    loc,
    // loc
    _null,
    // secondaryLoc
    _null,
    // locs
    index,
    // index
    _null,
    // profilerType
    mountInfo || _null
    // mountInfo
  );
};
var mergeChange = (prev, next) => {
  if (!prev && !next)
    return [];
  if (!prev?.length)
    return next;
  if (!next?.length)
    return prev;
  let prevHead = 0;
  let nextHead = 0;
  let prevTail = prev.length - 1;
  let nextTail = next.length - 1;
  while (prevHead <= prevTail && nextHead <= nextTail) {
    const prevHeadChange = prev[prevHead];
    const nextHeadChange = next[nextHead];
    const prevTailChange = prev[prevTail];
    const nextTailChange = next[nextTail];
    if (prevHeadChange.n === nextHeadChange.n) {
      prevHeadChange.c += nextHeadChange.c;
      if (!prevHeadChange.u) {
        prevHeadChange.u = nextHeadChange.u;
      }
      prevHead++;
      nextHead++;
    } else if (prevTailChange.n === nextTailChange.n) {
      prevTailChange.c += nextTailChange.c;
      if (!prevTailChange.u) {
        prevTailChange.u = nextTailChange.u;
      }
      prevTail--;
      nextTail--;
    } else {
      break;
    }
  }
  const changeIndexLookup = new _Map();
  for (; prevHead <= prevTail; prevHead++) {
    _mapSet.call(changeIndexLookup, prev[prevHead].n, prevHead);
  }
  for (; nextHead <= nextTail; nextHead++) {
    const nextChange = next[nextHead];
    const head = _mapGet.call(changeIndexLookup, nextChange.n);
    if (head == _null) {
      const index = prev.push(nextChange);
      _mapSet.call(changeIndexLookup, nextChange.n, index - 1);
      continue;
    }
    const prevChange = prev[head];
    prevChange.c += nextChange.c;
    if (!prevChange.u) {
      prevChange.u = nextChange.u;
    }
  }
  return prev;
};
var reportRender = (key, kind, loc, secondaryLoc, locs, selfTime, totalTime, count, self2, owner2, message, changes) => {
  const render = {
    k: kind,
    l: loc,
    l2: secondaryLoc,
    ls: locs,
    s: selfTime,
    t: totalTime,
    c: count,
    i: self2,
    o: owner2,
    m: message,
    d: changes,
    x: currentIndex
  };
  const batchKey = getRenderBatchIndexKey(key, kind, loc, owner2, message);
  if (_mapHas.call(batchIndexLookup, batchKey)) {
    const prevIndex = _mapGet.call(batchIndexLookup, batchKey);
    const prevRender = batch[prevIndex].r;
    prevRender.c += count;
    prevRender.t += totalTime;
    prevRender.s += selfTime;
    prevRender.d = mergeChange(prevRender.d, changes);
    return;
  }
  _mapSet.call(batchIndexLookup, batchKey, batch.length);
  const renderItem = {
    k: key,
    r: render
  };
  if (batch.length >= MAX_QUEUE_SIZE) {
    flush();
    return;
  }
  batch.push(renderItem);
  onRender?.();
};
var flush = () => {
  const renderItems = batch.length;
  if (false) {
    if (!navigator.onLine)
      return;
  }
  if (!url || !renderItems || !apiKey)
    return;
  try {
    const components = _Object.create(_null);
    metadataLookup.forEach((value, key) => {
      components[key] = {
        i: value.i,
        $: value.$
      };
    });
    const date = Date.now();
    const newEvents = new _Array(events.length);
    for (let i = 0, len = events.length; i < len; i++) {
      const event = events[i];
      let loc = _null;
      let key = event.k;
      if (key) {
        const parts = key.split(".");
        loc = parts[2] || _null;
        if (loc)
          key = parts[0] + "." + parts[1];
      }
      newEvents[i] = {
        n: event.n,
        t: event.t,
        l: Number(loc),
        d: date - event.d,
        k: event.k,
        a: event.a
      };
    }
    const payload = {
      batch,
      interactions: newEvents,
      components,
      session,
      buildId,
      apiKey,
      version: VERSION,
      react: React4.version || UNKNOWN,
      geo: void 0,
      date
    };
    events = [];
    currentId = _null;
    currentIndex = -1;
    const _batch = false ? [] : [...batch];
    if (true) {
      const DEV = _window[`${FLAG}DEV_`];
      const toolbarStore = DEV?.toolbarStore;
      if (toolbarStore) {
        toolbarStore.setData({
          pending: true
        });
        toolbarStore.pushBatch(_batch);
      }
    }
    transport(url, payload, proxySessionId).then(() => {
      if (true) {
        console.log(`[Million Lint] Ingested ${renderItems} events`, _batch);
        const DEV = _window[`${FLAG}DEV_`];
        const toolbarStore = DEV?.toolbarStore;
        if (toolbarStore) {
          toolbarStore.setData({
            pending: false
          });
          void compress(
            JSON.stringify(payload, (_key, value) => {
              if (value != null && value !== false) {
                if (typeof value === "number") {
                  return ~~value;
                }
                return value;
              }
            })
          ).then((compressed) => {
            const { bytes, items } = DEV.toolbarStore.data;
            if (["error", "dormant"].includes(toolbarStore.data.state)) {
              return;
            }
            toolbarStore.setData({
              bytes: compressed.byteLength + bytes,
              items: renderItems + items,
              state: "data"
            });
          });
        }
      }
    }).catch(() => {
      if (true) {
        const DEV = _window[`${FLAG}DEV_`];
        const toolbarStore = DEV?.toolbarStore;
        if (toolbarStore) {
          toolbarStore.setData({
            pending: false,
            error: "Failed to ingest events"
          });
        }
      }
    });
  } catch (_err) {
  }
  _setTimeout(reset, 0);
};
var reset = () => {
  batch.length = 0;
  batchIndexLookup.clear();
};
var registerMetadata = (key, size, reference) => {
  if (isSSR)
    return;
  if (reference && !(FLAG in reference)) {
    reference[FLAG] = key;
  }
  if (_mapHas.call(metadataLookup, key))
    return;
  _mapSet.call(metadataLookup, key, {
    i: 0,
    c: size,
    n: false
  });
};
var getNavigationEntry = () => {
  const navigationEntry = self.performance && performance.getEntriesByType?.("navigation")[0];
  if (navigationEntry && navigationEntry.responseStart > 0 && navigationEntry.responseStart < performance.now()) {
    return navigationEntry;
  }
  return _null;
};
var getActivationStart = () => {
  const entry = getNavigationEntry();
  const activationStart = entry?.activationStart;
  return activationStart || 0;
};
var getNavigationType = () => {
  const navEntry = getNavigationEntry();
  if (navEntry) {
    if (_document.prerendering || (navEntry?.activationStart || 0) > 0) {
      return "prerender";
    } else if (_document.wasDiscarded) {
      return "restore";
    } else if (navEntry.type) {
      return navEntry.type;
    }
  }
  return "navigate";
};
var observe = (type, callback, durationThreshold) => {
  try {
    if (PerformanceObserver.supportedEntryTypes.includes(type)) {
      const po = new PerformanceObserver((list) => {
        void Promise.resolve().then(() => {
          callback(list.getEntries());
        });
      });
      po.observe({
        type,
        durationThreshold,
        buffered: true
      });
      return po;
    }
  } catch (e) {
  }
  return _null;
};
var initWebVitals = () => {
  events.push({
    n: getNavigationType(),
    t: -1,
    d: Date.now(),
    k: _null,
    a: _null
  });
  const fcp = observe(
    "paint",
    (entries) => {
      for (let i = 0, len = entries.length; i < len; i++) {
        const entry = entries[i];
        if (entry.name === "first-contentful-paint") {
          fcp.disconnect();
          const value = Math.max(entry.startTime - getActivationStart(), 0);
          events.push({
            n: "FCP",
            t: ~~value,
            d: Date.now(),
            k: _null,
            a: _null
          });
        }
      }
    },
    _null
  );
  const lcp = observe(
    "largest-contentful-paint",
    (entries) => {
      for (let i = 0, len = entries.length; i < len; i++) {
        const entry = entries[i];
        lcp.disconnect();
        const value = Math.max(entry.startTime - getActivationStart(), 0);
        events.push({
          n: "LCP",
          t: ~~value,
          d: Date.now(),
          k: _null,
          a: _null
        });
      }
    },
    _null
  );
  let sessionValue = 0;
  let sessionEntries = [];
  let maxValue = 0;
  observe(
    "layout-shift",
    (entries) => {
      const diff = [];
      for (let i = 0, len = entries.length; i < len; i++) {
        const entry = entries[i];
        const firstSessionEntry = sessionEntries[0];
        const lastSessionEntry = sessionEntries[sessionEntries.length - 1];
        if (entry.hadRecentInput)
          continue;
        const sources = entry.sources;
        for (let j = 0, len2 = sources.length; j < len2; j++) {
          const attribution = sources[j];
          const { currentRect, previousRect } = attribution;
          diff.push({
            h: currentRect.height - previousRect.height,
            w: currentRect.width - previousRect.width,
            l: currentRect.left - previousRect.left,
            t: currentRect.top - previousRect.top
          });
        }
        if (sessionValue && entry.startTime - lastSessionEntry.startTime < 1e3 && entry.startTime - firstSessionEntry.startTime < 5e3) {
          sessionValue += entry.value;
          sessionEntries.push(entry);
        } else {
          sessionValue = entry.value;
          sessionEntries = [entry];
        }
      }
      if (sessionValue > maxValue) {
        maxValue = sessionValue;
        events.push({
          n: "CLS",
          t: sessionValue,
          d: Date.now(),
          k: _null,
          a: diff
        });
      }
    },
    _null
  );
  const inp = observe(
    "event",
    (entries) => {
      let maxEntry = _null;
      for (let i = 0, len = entries.length; i < len; i++) {
        const entry = entries[i];
        if (!maxEntry || entry.duration >= maxEntry.duration) {
          maxEntry = entry;
        }
      }
      if (!maxEntry)
        return;
      const id = maxEntry.interactionId;
      if (currentId !== id) {
        let key = _null;
        let target = maxEntry.target;
        while (target) {
          if (target[FLAG]) {
            key = target[FLAG];
            if (!maxEntry.target[FLAG]) {
              maxEntry.target[FLAG] = key;
            }
            break;
          }
          target = target.parentNode;
        }
        currentId = id;
        currentIndex = events.push({
          n: maxEntry.name,
          t: maxEntry.duration,
          d: Date.now(),
          k: key,
          a: _null
        }) - 1;
      }
    },
    40
  );
  if (inp && "PerformanceEventTiming" in self && "interactionId" in PerformanceEventTiming.prototype) {
    inp.observe({ type: "first-input", buffered: true });
  }
};
var init = (options) => {
  if (isSSR)
    return;
  _window[FLAG] = true;
  url = options?.url || url || ENDPOINT;
  buildId ||= options?.id;
  apiKey = options?.apiKey;
  proxySessionId = options?.sessionId;
  if (inited)
    return;
  inited = true;
  if (true) {
    try {
      void fetch(`${url}/reset`, {
        mode: proxySessionId ? void 0 : "no-cors",
        headers: {
          "X-Session-Id": proxySessionId || ""
        }
      }).then(() => {
      }).catch(() => {
      });
    } catch (_err) {
    }
    console.log(`[Million Lint] Initialized with ${url}`);
  }
  if (_document.prerendering) {
    addEventListener("prerenderingchange", initWebVitals, true);
  } else {
    initWebVitals();
  }
  const lazyFlush = () => onIdle(flush);
  onHidden(lazyFlush);
  const debouncedLazyFlush = debounce(lazyFlush, FLUSH_TIMEOUT);
  const checkExpiry = debounce(() => {
    session = getSession();
  }, SESSION_EXPIRE_TIMEOUT);
  onRender = () => {
    debouncedLazyFlush();
    checkExpiry();
    if (true) {
      const DEV = _window[`${FLAG}DEV_`];
      const toolbarStore = DEV?.toolbarStore;
      if (!toolbarStore)
        return;
      if (toolbarStore.data.state === "hidden") {
        toolbarStore.setData({
          state: "connecting"
        });
      }
      DEV.url = url;
      DEV.id = buildId;
      DEV.proxySessionId = proxySessionId;
    }
  };
};
if (!isSSR) {
  const DEV = {
    batch,
    flush,
    metadataLookup,
    session,
    inited,
    buildId,
    apiKey,
    url,
    FLAG
  };
  _window[`${FLAG}DEV_`] = DEV;
  if (!localStorage.getItem("DISABLE_MILLION_TOOLBAR")) {
    void Promise.resolve().then(() => (init_toolbar(), toolbar_exports));
  }
}
export {
  $$,
  init,
  registerMetadata,
  reset,
  useCapture
};
/**
 * @license React
 * use-sync-external-store-shim.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
