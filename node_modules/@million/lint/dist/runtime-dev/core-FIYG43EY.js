"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } } function _nullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } } function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }

























var _chunk2L6AGLW2js = require('./chunk-2L6AGLW2.js');

// runtime/src/core/index.ts
var _react = require('react'); var React2 = _interopRequireWildcard(_react); var React = _interopRequireWildcard(_react);

// runtime/src/core/utils/helpers.ts
var generateId = () => {
  return Math.random().toString(36).substring(2) + Date.now();
};
var getRenderBatchIndexKey = (key, kind, loc, owner, error) => {
  return (
    // eslint-disable-next-line prefer-template
    key + "." + kind + "." + loc + "." + (owner || "") + "." + (error || "")
  );
};

// runtime/src/core/session.ts
var getGpuRenderer = () => {
  if (!("chrome" in _chunk2L6AGLW2js._window))
    return "";
  const gl = document.createElement("canvas").getContext("webgl", { powerPreference: "high-performance" });
  if (!gl)
    return "";
  const ext = gl.getExtension("WEBGL_debug_renderer_info");
  return ext ? gl.getParameter(ext.UNMASKED_RENDERER_WEBGL) : "";
};
var getSession = () => {
  if (_chunk2L6AGLW2js.isSSR)
    return _chunk2L6AGLW2js._null;
  const id = generateId();
  const url2 = _chunk2L6AGLW2js._window.location.toString();
  const wifi = _optionalChain([navigator, 'access', _ => _.connection, 'optionalAccess', _2 => _2.effectiveType]) || _chunk2L6AGLW2js.UNKNOWN;
  const cpu = navigator.hardwareConcurrency;
  const mem = navigator.deviceMemory;
  const session2 = {
    id,
    url: url2,
    wifi,
    cpu,
    mem,
    gpu: _chunk2L6AGLW2js.UNKNOWN
  };
  _chunk2L6AGLW2js.onIdle.call(void 0, () => {
    session2.gpu = getGpuRenderer();
  });
  return session2;
};

// runtime/src/core/transport.ts
var contentType = "application/json";
var supportsCompression = typeof CompressionStream === "function";
var compress = async (payload) => {
  const stream = new Blob([payload], { type: contentType }).stream().pipeThrough(new CompressionStream("gzip"));
  return new Response(stream).arrayBuffer();
};
var transport = async (url2, payload) => {
  const fail = { ok: false };
  if (_chunk2L6AGLW2js.isSSR)
    return fail;
  let kind = _chunk2L6AGLW2js._null;
  const json = JSON.stringify(payload, (key, value) => {
    if (key === "k")
      kind = value;
    if (
      // eslint-disable-next-line eqeqeq
      value != null && value !== false && key !== "n" || kind === 2
    ) {
      return value;
    }
  });
  const shouldCompress = json.length > _chunk2L6AGLW2js.GZIP_MIN_LEN;
  const body = shouldCompress && supportsCompression ? await compress(json) : json;
  if (!navigator.onLine)
    return fail;
  const headers = {
    "Content-Type": contentType,
    // @ts-expect-error - Content-Encoding can be undefined
    "Content-Encoding": shouldCompress ? "gzip" : void 0
  };
  return fetch(url2, {
    body,
    method: "POST",
    // make sure payload actually gets thru
    keepalive: true,
    priority: "low",
    mode: "no-cors",
    headers
  });
};

// runtime/src/core/utils/internals.ts

var REACT_PREFIX = "Symbol(react.";
var ELEMENT_SYMBOL_STRING = REACT_PREFIX + "element)";
var FORWARD_REF_SYMBOL_STRING = REACT_PREFIX + "forward_ref)";
var LAZY_SYMBOL_STRING = REACT_PREFIX + "lazy)";
var MEMO_SYMBOL_STRING = REACT_PREFIX + "memo)";
function useFiber() {
  try {
    const fiber = React.useRef();
    React.useState(() => {
      const bind = _chunk2L6AGLW2js.functionProto.bind;
      _chunk2L6AGLW2js.functionProto.bind = function(self, maybeFiber) {
        if (self === _chunk2L6AGLW2js._null && typeof _optionalChain([maybeFiber, 'optionalAccess', _3 => _3.type]) === "function") {
          fiber.current = maybeFiber;
          _chunk2L6AGLW2js.functionProto.bind = bind;
        }
        return bind.apply(this, arguments);
      };
    });
    return fiber.current;
  } catch (e) {
    return _chunk2L6AGLW2js._null;
  }
}
var getTimings = (fiber) => {
  const totalTime = _nullishCoalesce(_optionalChain([fiber, 'optionalAccess', _4 => _4.actualDuration]), () => ( 0));
  let selfTime = totalTime;
  let child = _optionalChain([fiber, 'optionalAccess', _5 => _5.child]);
  while (totalTime > 0 && child != _chunk2L6AGLW2js._null) {
    selfTime -= _optionalChain([child, 'optionalAccess', _6 => _6.actualDuration]) || 0;
    child = child.sibling;
  }
  return {
    /**
     * totalTime
     */
    t: totalTime,
    /**
     * selfTime
     */
    s: selfTime
  };
};
var getOwner = (fiber) => {
  let type = _optionalChain([fiber, 'optionalAccess', _7 => _7._debugOwner, 'optionalAccess', _8 => _8.type]);
  if (!type) {
    const owner = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner.current;
    type = _optionalChain([owner, 'optionalAccess', _9 => _9._debugOwner, 'optionalAccess', _10 => _10.type]);
  }
  if (!type || typeof type !== "function")
    return _chunk2L6AGLW2js._null;
  return type[_chunk2L6AGLW2js.FLAG] || _chunk2L6AGLW2js._null;
};
var truncateString = (value, length) => {
  return value.length > length ? value.slice(0, length) + "\u2026" : value;
};
var serialize = (value) => {
  switch (typeof value) {
    case "function":
      return truncateString(value.toString(), 20);
    case "string":
      return truncateString(value, 20);
    case "object":
      if (value === _chunk2L6AGLW2js._null) {
        return "null";
      }
      if (_chunk2L6AGLW2js._Array.isArray(value)) {
        return value.length > 0 ? "[\u2026]" : "[]";
      }
      if (typeof value.$$typeof === "symbol" && String(value.$$typeof) === ELEMENT_SYMBOL_STRING) {
        return "<" + (value.type.displayName || value.type.name || "") + (_chunk2L6AGLW2js._Object.keys(value.props).length > 0 ? " \u2026" : "") + ">";
      }
      if (typeof value === "object" && value !== _chunk2L6AGLW2js._null && value.constructor === _chunk2L6AGLW2js._Object) {
        for (const key in value) {
          if (_chunk2L6AGLW2js._objectHasOwnProperty.call(value, key)) {
            return "{\u2026}";
          }
        }
        return "{}";
      }
      const tagString = _chunk2L6AGLW2js._objectToString.call(value).slice(8, -1);
      if (tagString === "Object") {
        const constructor = _optionalChain([_chunk2L6AGLW2js._Object, 'access', _11 => _11.getPrototypeOf, 'call', _12 => _12(value), 'optionalAccess', _13 => _13.constructor]);
        if (typeof constructor === "function") {
          return (constructor.displayName || constructor.name || "") + "{\u2026}";
        }
      }
      return tagString + "{\u2026}";
    default:
      return String(value);
  }
};
var getFunctionFromJSX = (element) => {
  if (typeof element === "function") {
    return element;
  }
  if (typeof element !== "object") {
    return _chunk2L6AGLW2js._null;
  }
  const type = element.type;
  if (typeof type === "function")
    return type;
  if (typeof type !== "object")
    return _chunk2L6AGLW2js._null;
  if ("$$typeof" in type) {
    switch (String(type.$$typeof)) {
      case FORWARD_REF_SYMBOL_STRING:
        return getFunctionFromJSX(element.type.render);
      case MEMO_SYMBOL_STRING:
      case LAZY_SYMBOL_STRING:
        return getFunctionFromJSX(element.type);
    }
  }
  return _chunk2L6AGLW2js._null;
};
var setRef = (ref, value) => {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref !== null && ref !== void 0) {
    ref.current = value;
  }
};
var mergeProps = (nextProps, prevProps) => {
  const overrideProps = _chunk2L6AGLW2js._Object.assign({}, prevProps);
  for (const propName in prevProps) {
    const nextPropValue = nextProps[propName];
    const prevPropValue = prevProps[propName];
    if (propName.startsWith("on")) {
      if (nextPropValue && prevPropValue) {
        overrideProps[propName] = function() {
          prevPropValue.apply(this, arguments);
          nextPropValue.apply(this, arguments);
        };
      } else if (nextPropValue) {
        overrideProps[propName] = nextPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = Object.assign(prevPropValue, nextPropValue);
    } else if (propName === "className") {
      overrideProps[propName] = [nextPropValue, prevPropValue].filter(Boolean).join(" ");
    }
  }
  return _chunk2L6AGLW2js._Object.assign(overrideProps, nextProps);
};

// runtime/src/core/utils/afterframe.ts
var callbacks = [];
var channel = new MessageChannel();
var postMessage = function() {
  this.postMessage(void 0);
}.bind(channel.port2);
channel.port1.onmessage = () => {
  const toFlush = callbacks;
  callbacks = [];
  for (let i = 0, len = toFlush.length; i < len; i++) {
    toFlush[i]();
  }
};
channel = null;
var afterFrame = (callback) => {
  if (callbacks.push(callback) === 1) {
    requestAnimationFrame(postMessage);
  }
};

// runtime/src/core/index.ts
var batchIndexLookup = new (0, _chunk2L6AGLW2js._Map)();
var metadataLookup = new (0, _chunk2L6AGLW2js._Map)();
var batch = [];
var inited = false;
var session = getSession();
var url = _chunk2L6AGLW2js._null;
var apiKey;
var buildId;
var onRender = _chunk2L6AGLW2js._null;
var getMetadata = (key) => {
  return _chunk2L6AGLW2js._mapGet.call(metadataLookup, key);
};
var getChange = (prevValue, nextValue) => {
  if (_chunk2L6AGLW2js._Object.is(prevValue, nextValue))
    return _chunk2L6AGLW2js._null;
  const prev = serialize(prevValue);
  const next = serialize(nextValue);
  const type = nextValue ? typeof nextValue : typeof prevValue;
  const unstable = prev === next && ["object", "function"].includes(type);
  return {
    // unstable
    u: unstable,
    // type
    t: type,
    // count
    c: 1,
    // index: (if it's a change of the deps array, this will be the index of the dep)
    i: _chunk2L6AGLW2js._null,
    // name: used to help identify the change
    // prop change postfixes this with the name of the prop
    n: prev === next ? prev : prev + next
  };
};
var captureClass = (key, data, setState, loc, index) => {
  return function() {
    const value = arguments[0];
    const fiber = useFiber();
    const owner = getOwner(fiber);
    const {
      s,
      t
      /* totalTime */
    } = getTimings(fiber);
    const prevValue = data.c[index];
    setState.apply(this, arguments);
    const change = getChange(prevValue, value);
    if (change) {
      reportRender(
        // key: encode(filename).encoded(componentName)
        // (e.g. "/some/file/path/index.jsx.App")
        key,
        4 /* Reducer */,
        // CaptureKind
        // loc: encode(SourceLocation)
        // e.g. `this.setState(newVal)` -> encode([1, 2, 3, 4])
        loc,
        _chunk2L6AGLW2js._null,
        // secondaryLoc
        _chunk2L6AGLW2js._null,
        // locs
        s,
        // selfTime
        t,
        // totalTime
        1,
        // count
        _chunk2L6AGLW2js._null,
        // self
        owner,
        // owner
        _chunk2L6AGLW2js._null,
        // error
        [change]
        // changes
      );
      data.c[data.i] = value;
    }
    return value;
  };
};
var captureDeps = (key, data, deps, loc, locs, index) => {
  if (!_chunk2L6AGLW2js._isArray.call(void 0, deps))
    return deps;
  const prevDeps = data.c[index];
  const fiber = useFiber();
  const owner = getOwner(fiber);
  const {
    s,
    t
    /* totalTime */
  } = getTimings(fiber);
  if (prevDeps) {
    const changes = [];
    for (let i = 0, len = deps.length; i < len; i++) {
      const prevDepValue = prevDeps[i];
      const nextDepValue = deps[i];
      const change = getChange(prevDepValue, nextDepValue);
      if (!change)
        continue;
      changes.push(change);
    }
    if (changes.length) {
      reportRender(
        // key: encode(filename).encoded(componentName)
        // (e.g. "/some/file/path/index.jsx.App")
        key,
        1 /* Deps */,
        // CaptureKind
        // loc: encode(SourceLocation)
        // e.g. `[foo, bar, baz]` -> encode([1, 2, 3, 4])
        loc,
        _chunk2L6AGLW2js._null,
        // secondaryLoc
        // locs: encode([Dep1SourceLocation, Dep2SourceLocation, ...])
        // e.g. `[foo, bar, baz]` -> encode([[1, 2, 3, 4], [5, 6, 7, 8], ...])
        locs,
        s,
        // selfTime
        t,
        // totalTime
        1,
        // count
        _chunk2L6AGLW2js._null,
        // self
        owner,
        // owner
        _chunk2L6AGLW2js._null,
        // error
        changes
        // changes
      );
    }
  }
  data.c[index] = deps;
  return deps;
};
var captureValue = (key, data, value, loc, index) => {
  const owner = getOwner(_chunk2L6AGLW2js._null);
  const prevValue = data.c[index];
  if (prevValue) {
    const change = getChange(prevValue, value);
    if (!change)
      return value;
    reportRender(
      // key: encode(filename).encoded(componentName)
      // e.g. "/some/file/path/index.jsx.App"
      key,
      // CaptureKind
      8 /* Value */,
      // loc: encode(SourceLocation)
      loc,
      // loc: encode(SourceLocation)
      _chunk2L6AGLW2js._null,
      // secondaryLoc
      _chunk2L6AGLW2js._null,
      // locs
      0,
      // selfTime
      0,
      // totalTime
      1,
      // count
      _chunk2L6AGLW2js._null,
      // self
      owner,
      // owner
      _chunk2L6AGLW2js._null,
      // error
      [change]
      // changes
    );
  }
  data.c[index] = value;
  return value;
};
var captureProps = (key, data, props, loc, index) => {
  if (typeof props !== "object")
    return props;
  const prevProps = data.c[index];
  const fiber = useFiber();
  const owner = getOwner(fiber);
  if (prevProps) {
    const changes = [];
    for (const name in props) {
      const prevPropValue = prevProps[name];
      const nextPropValue = props[name];
      const change = getChange(prevPropValue, nextPropValue);
      if (!change)
        continue;
      change.n = name;
      changes.push(change);
    }
    if (changes.length) {
      const {
        s,
        t
        /* totalTime */
      } = getTimings(fiber);
      reportRender(
        // key: encode(filename).encoded(componentName)
        // e.g. "/some/file/path/index.jsx.App"
        key,
        2 /* Props */,
        // CaptureKind
        loc,
        // loc: encode(SourceLocation)
        _chunk2L6AGLW2js._null,
        // secondaryLoc
        _chunk2L6AGLW2js._null,
        // locs
        s,
        // selfTime
        t,
        // totalTime
        1,
        // count
        _chunk2L6AGLW2js._null,
        // self
        owner,
        // owner
        _chunk2L6AGLW2js._null,
        // error
        changes
        // changes
      );
    }
  }
  data.c[index] = props;
  return props;
};
var captureReducer = (key, data, value, loc, index) => {
  if (!_chunk2L6AGLW2js._isArray.call(void 0, value))
    return value;
  const fiber = useFiber();
  const owner = getOwner(fiber);
  const dispatcher = value[1];
  data.c[index] = value[0];
  value[1] = function(nextValue) {
    const prevValue = value[0];
    dispatcher(nextValue);
    const change = getChange(prevValue, nextValue);
    if (!change)
      return;
    const {
      s,
      t
      /* totalTime */
    } = getTimings(fiber);
    reportRender(
      // key: encode(filename).encoded(componentName)
      // e.g. "/some/file/path/index.jsx.App"
      key,
      4 /* Reducer */,
      // CaptureKind
      loc,
      // loc: encode(SourceLocation)
      _chunk2L6AGLW2js._null,
      // secondaryLoc
      _chunk2L6AGLW2js._null,
      // locs
      s,
      // selfTime
      t,
      // totalTime
      1,
      // count
      _chunk2L6AGLW2js._null,
      // self
      owner,
      // owner
      _chunk2L6AGLW2js._null,
      // error
      [change]
      // changes
    );
  };
  return value;
};
var captureFunction = (key, fn, loc) => {
  if (typeof fn !== "function")
    return fn;
  if (_chunk2L6AGLW2js.FLAG in fn)
    return fn;
  fn[_chunk2L6AGLW2js.FLAG] = true;
  return function() {
    const startTime = _chunk2L6AGLW2js._performance.now();
    try {
      const ret = fn.apply(this, arguments);
      const endTime = _chunk2L6AGLW2js._performance.now();
      afterFrame(() => {
        const selfTime = endTime - startTime;
        const totalTime = _chunk2L6AGLW2js._performance.now() - startTime;
        reportRender(
          // key: encode(filename).encoded(componentName)
          // e.g. "/some/file/path/index.jsx.App"
          key,
          128 /* Function */,
          loc,
          // loc
          null,
          // secondaryLoc
          _chunk2L6AGLW2js._null,
          // locs
          selfTime,
          // selfTime
          totalTime,
          // totalTime
          1,
          // count
          null,
          // self
          null,
          // owner
          null,
          // error
          []
          // changes
        );
      });
      return ret;
    } catch (error) {
      reportRender(
        // key: encode(filename).encoded(componentName)
        // e.g. "/some/file/path/index.jsx.App"
        key,
        256 /* Error */,
        loc,
        // loc
        null,
        // secondaryLoc
        _chunk2L6AGLW2js._null,
        // locs
        0,
        // selfTime
        0,
        // totalTime
        1,
        // count
        null,
        // self
        null,
        // owner
        error.message.split("\n")[0],
        // error
        []
        // changes
      );
      throw error;
    }
  };
};
var Profiler = class extends React2.Component {
  constructor(props) {
    super(props);
    this.m = _chunk2L6AGLW2js._performance.now();
  }
  componentDidMount() {
    const mountTime = this.m;
    if (mountTime) {
      const selfTime = _chunk2L6AGLW2js._performance.now() - mountTime;
      afterFrame(() => {
        _optionalChain([this, 'access', _14 => _14.props, 'access', _15 => _15._r, 'optionalCall', _16 => _16(
          64 /* JSXUpdate */,
          selfTime,
          _chunk2L6AGLW2js._performance.now() - mountTime
        )]);
      });
      this.m = void 0;
    }
  }
  shouldComponentUpdate() {
    if (this.m) {
      this.u = _chunk2L6AGLW2js._performance.now();
    }
    return true;
  }
  componentDidUpdate() {
    const updateTime = this.u;
    if (updateTime) {
      const selfTime = _chunk2L6AGLW2js._performance.now() - updateTime;
      afterFrame(() => {
        _optionalChain([this, 'access', _17 => _17.props, 'access', _18 => _18._r, 'optionalCall', _19 => _19(
          64 /* JSXUpdate */,
          selfTime,
          _chunk2L6AGLW2js._performance.now() - updateTime
        )]);
      });
      this.u = void 0;
    }
  }
  componentWillUnmount() {
    const unmountTime = _chunk2L6AGLW2js._performance.now();
    afterFrame(() => {
      const time = _chunk2L6AGLW2js._performance.now() - unmountTime;
      _optionalChain([this, 'access', _20 => _20.props, 'access', _21 => _21._r, 'optionalCall', _22 => _22(64 /* JSXUpdate */, time, time)]);
    });
  }
  render() {
    return this.props.children;
  }
};
var AnyaProfiler = React2.forwardRef((props, forwardedRef) => {
  const element = props._l;
  const originalRef = element.ref;
  if (React2.isValidElement(element)) {
    let ref = originalRef;
    if (forwardedRef) {
      ref = (value) => {
        setRef(originalRef, value);
        setRef(forwardedRef, value);
      };
    }
    const newProps = _chunk2L6AGLW2js._Object.assign(mergeProps(element.props, props), {
      ref
    });
    newProps._r = void 0;
    newProps._l = void 0;
    return React2.createElement(Profiler, {
      key: element.key,
      _r: props._r,
      children: React2.cloneElement(element, newProps)
    });
  }
  return props.children;
});
var captureJSX = (key, data, element, loc, secondaryLoc, index) => {
  const owner = getOwner(null);
  const reference = getFunctionFromJSX(element);
  const self = _optionalChain([reference, 'optionalAccess', _23 => _23[_chunk2L6AGLW2js.FLAG]]);
  return React2.createElement(AnyaProfiler, {
    _l: element,
    // assume children is a JSX element!
    key: element.key || void 0,
    _r: (kind, selfTime, totalTime) => {
      const changes = [];
      const prevValue = data.c[index];
      if (prevValue) {
        const change = getChange(prevValue, reference);
        if (!change)
          return;
        changes.push(change);
      }
      reportRender(
        // key: encode(filename).encoded(componentName)
        // e.g. "/some/file/path/index.jsx.App"
        key,
        // JSXMount = 'mount'
        // JSXUpdate = 'update' | 'nested-update' | 'unmount'
        kind,
        // loc = scoped source location of the JSX element,
        // or the location of the JSX element
        loc,
        secondaryLoc,
        // secondaryLoc = location of the JSX element
        _chunk2L6AGLW2js._null,
        // locs
        selfTime,
        // selfTime
        totalTime,
        // totalTime
        1,
        // count
        self,
        // self
        owner,
        // owner
        _chunk2L6AGLW2js._null,
        // error
        changes
        // changes
      );
      data.c[data.i] = reference;
    }
  });
};
var captureMount = (data) => {
  React2.useEffect(() => {
    if (!data)
      return;
    data.i++;
    return () => {
      data.i--;
    };
  }, []);
};
var capture = (kind, key, value, loc, secondaryLoc, locs, index) => {
  if (_chunk2L6AGLW2js.isSSR)
    return;
  const data = getMetadata(key);
  if (!data)
    return value;
  if (kind & 512 /* ComponentMount */) {
    return captureMount(data);
  } else if (kind & 2 /* Props */) {
    return captureProps(key, data, value, loc, index);
  } else if (kind & 4 /* Reducer */) {
    return captureReducer(key, data, value, loc, index);
  } else if (kind & 1 /* Deps */) {
    return captureDeps(key, data, value, loc, locs, index);
  } else if (kind & 16 /* JSX */) {
    return captureJSX(key, data, value, loc, secondaryLoc, index);
  } else if (kind & 8 /* Value */) {
    return captureValue(key, data, value, loc, index);
  } else if (kind & 128 /* Function */) {
    return captureFunction(key, value, loc);
  } else if (kind & 0 /* ClassSetState */) {
    return captureClass(key, data, value, loc, index);
  }
  return value;
};
var mergeChange = (prev, next) => {
  if (!prev && !next)
    return [];
  if (!_optionalChain([prev, 'optionalAccess', _24 => _24.length]))
    return next;
  if (!_optionalChain([next, 'optionalAccess', _25 => _25.length]))
    return prev;
  let prevHead = 0;
  let nextHead = 0;
  let prevTail = prev.length - 1;
  let nextTail = next.length - 1;
  while (prevHead < prevTail && nextHead < nextTail) {
    const prevHeadChange = prev[prevHead];
    const nextHeadChange = next[nextHead];
    const prevTailChange = prev[prevTail - 1];
    const nextTailChange = next[nextTail - 1];
    if (prevHeadChange.n === nextHeadChange.n) {
      prevHeadChange.c += nextHeadChange.c;
      if (!prevHeadChange.u) {
        prevHeadChange.u = nextHeadChange.u;
      }
      prevHead++;
      nextHead++;
    } else if (prevTailChange.n === nextTailChange.n) {
      prevTailChange.c += nextTailChange.c;
      if (!prevTailChange.u) {
        prevTailChange.u = nextTailChange.u;
      }
      prevTail--;
      nextTail--;
    } else {
      break;
    }
  }
  const changeIndexLookup = new (0, _chunk2L6AGLW2js._Map)();
  for (; prevHead < prevTail; prevHead++) {
    _chunk2L6AGLW2js._mapSet.call(changeIndexLookup, prev[prevHead].n, prevHead);
  }
  for (; nextHead < nextTail; nextHead++) {
    const nextProp = next[nextHead];
    const prevPropIndex = _chunk2L6AGLW2js._mapGet.call(changeIndexLookup, nextProp.n);
    if (prevPropIndex === void 0) {
      const index = prev.push(nextProp);
      _chunk2L6AGLW2js._mapSet.call(changeIndexLookup, nextProp.n, index);
      continue;
    }
    const prevProp = prev[prevPropIndex];
    prevProp.c++;
    if (!prevProp.u) {
      prevProp.u = nextProp.u;
    }
  }
  return prev;
};
var reportRender = (key, kind, loc, secondaryLoc, locs, selfTime, totalTime, count, self, owner, error, changes) => {
  const render = {
    k: kind,
    l: loc,
    l2: secondaryLoc,
    ls: locs,
    s: selfTime,
    t: totalTime,
    c: count,
    i: self,
    o: owner,
    e: error,
    d: changes
  };
  const batchKey = getRenderBatchIndexKey(key, kind, loc, owner, error);
  if (_chunk2L6AGLW2js._mapHas.call(batchIndexLookup, batchKey)) {
    const prevIndex = _chunk2L6AGLW2js._mapGet.call(batchIndexLookup, batchKey);
    const prevRender = batch[prevIndex].r;
    prevRender.c++;
    prevRender.t += render.t;
    prevRender.s += render.s;
    prevRender.d = mergeChange(prevRender.d, render.d);
    return;
  }
  _chunk2L6AGLW2js._mapSet.call(batchIndexLookup, batchKey, batch.length);
  const renderItem = {
    k: key,
    r: render
  };
  if (batch.length >= _chunk2L6AGLW2js.MAX_QUEUE_SIZE) {
    flush();
    return;
  }
  batch.push(renderItem);
  _optionalChain([onRender, 'optionalCall', _26 => _26()]);
};
var flush = () => {
  const renderItems = batch.length;
  if (!url || !navigator.onLine || !renderItems || !apiKey)
    return;
  try {
    const components = _chunk2L6AGLW2js._Object.create(_chunk2L6AGLW2js._null);
    metadataLookup.forEach((value, key) => {
      components[key] = value.i;
    });
    const payload = {
      batch,
      components,
      session,
      buildId,
      apiKey,
      version: _chunk2L6AGLW2js.VERSION,
      react: React2.version || _chunk2L6AGLW2js.UNKNOWN,
      geo: void 0
    };
    void transport(url, payload).then(() => {
      if (true) {
        console.log(`[Million Lint] Ingested ${renderItems} events`);
      }
    }).catch(() => {
    });
  } catch (_err) {
  }
  reset();
};
var reset = () => {
  batch.length = 0;
  batchIndexLookup.clear();
};
var registerMetadata = (key, size, reference) => {
  if (_chunk2L6AGLW2js.isSSR)
    return;
  if (_chunk2L6AGLW2js._mapHas.call(metadataLookup, key))
    return;
  if (reference && !(_chunk2L6AGLW2js.FLAG in reference)) {
    reference[_chunk2L6AGLW2js.FLAG] = key;
  }
  const cache = size ? new (0, _chunk2L6AGLW2js._Array)(size) : _chunk2L6AGLW2js._null;
  _chunk2L6AGLW2js._mapSet.call(metadataLookup, key, {
    r: reference,
    c: cache,
    i: 0
  });
};
var init = (options) => {
  if (_chunk2L6AGLW2js.isSSR)
    return;
  _chunk2L6AGLW2js._window[_chunk2L6AGLW2js.FLAG] = true;
  url = _optionalChain([options, 'optionalAccess', _27 => _27.url]) || url || _chunk2L6AGLW2js.ENDPOINT;
  buildId ||= _optionalChain([options, 'optionalAccess', _28 => _28.id]);
  apiKey = _optionalChain([options, 'optionalAccess', _29 => _29.apiKey]);
  if (inited)
    return;
  inited = true;
  if (true) {
    console.log(`[Million Lint] Initialized with ${url}`);
  }
  const lazyFlush = () => _chunk2L6AGLW2js.onIdle.call(void 0, flush);
  _chunk2L6AGLW2js.onHidden.call(void 0, lazyFlush);
  const debouncedLazyFlush = _chunk2L6AGLW2js.debounce.call(void 0, lazyFlush, _chunk2L6AGLW2js.FLUSH_TIMEOUT);
  const checkExpiry = _chunk2L6AGLW2js.debounce.call(void 0, () => {
    session = getSession();
  }, _chunk2L6AGLW2js.SESSION_EXPIRE_TIMEOUT);
  onRender = () => {
    debouncedLazyFlush();
    checkExpiry();
  };
};
if (true) {
  (() => {
    if (_chunk2L6AGLW2js.isSSR)
      return;
    window[`${_chunk2L6AGLW2js.FLAG}DEV_`] = {
      batch,
      flush,
      reset
    };
  })();
}





exports.capture = capture; exports.init = init; exports.registerMetadata = registerMetadata; exports.reset = reset;
