import {
  ENDPOINT,
  FLAG,
  FLUSH_TIMEOUT,
  GZIP_MIN_LEN,
  MAX_QUEUE_SIZE,
  SESSION_EXPIRE_TIMEOUT,
  UNKNOWN,
  VERSION,
  _Array,
  _Map,
  _Object,
  _isArray,
  _mapGet,
  _mapHas,
  _mapSet,
  _null,
  _objectHasOwnProperty,
  _objectToString,
  _performance,
  _window,
  debounce,
  functionProto,
  isSSR,
  onHidden,
  onIdle
} from "./chunk-J4YCMAH7.mjs";

// runtime/src/core/index.ts
import * as React2 from "react";

// runtime/src/core/utils/helpers.ts
var generateId = () => {
  return Math.random().toString(36).substring(2) + Date.now();
};
var getRenderBatchIndexKey = (key, kind, loc, owner, error) => {
  return (
    // eslint-disable-next-line prefer-template
    key + "." + kind + "." + loc + "." + (owner || "") + "." + (error || "")
  );
};

// runtime/src/core/session.ts
var getGpuRenderer = () => {
  if (!("chrome" in _window))
    return "";
  const gl = document.createElement("canvas").getContext("webgl", { powerPreference: "high-performance" });
  if (!gl)
    return "";
  const ext = gl.getExtension("WEBGL_debug_renderer_info");
  return ext ? gl.getParameter(ext.UNMASKED_RENDERER_WEBGL) : "";
};
var getSession = () => {
  if (isSSR)
    return _null;
  const id = generateId();
  const url2 = _window.location.toString();
  const wifi = navigator.connection?.effectiveType || UNKNOWN;
  const cpu = navigator.hardwareConcurrency;
  const mem = navigator.deviceMemory;
  const session2 = {
    id,
    url: url2,
    wifi,
    cpu,
    mem,
    gpu: UNKNOWN
  };
  onIdle(() => {
    session2.gpu = getGpuRenderer();
  });
  return session2;
};

// runtime/src/core/transport.ts
var contentType = "application/json";
var supportsCompression = typeof CompressionStream === "function";
var compress = async (payload) => {
  const stream = new Blob([payload], { type: contentType }).stream().pipeThrough(new CompressionStream("gzip"));
  return new Response(stream).arrayBuffer();
};
var transport = async (url2, payload) => {
  const fail = { ok: false };
  if (isSSR)
    return fail;
  let kind = _null;
  const json = JSON.stringify(payload, (key, value) => {
    if (key === "k")
      kind = value;
    if (
      // eslint-disable-next-line eqeqeq
      value != null && value !== false && key !== "n" || kind === 2
    ) {
      return value;
    }
  });
  const shouldCompress = json.length > GZIP_MIN_LEN;
  const body = shouldCompress && supportsCompression ? await compress(json) : json;
  if (!navigator.onLine)
    return fail;
  const headers = {
    "Content-Type": contentType,
    // @ts-expect-error - Content-Encoding can be undefined
    "Content-Encoding": shouldCompress ? "gzip" : void 0
  };
  return fetch(url2, {
    body,
    method: "POST",
    // make sure payload actually gets thru
    keepalive: true,
    priority: "low",
    mode: "no-cors",
    headers
  });
};

// runtime/src/core/utils/internals.ts
import * as React from "react";
var REACT_PREFIX = "Symbol(react.";
var ELEMENT_SYMBOL_STRING = REACT_PREFIX + "element)";
var FORWARD_REF_SYMBOL_STRING = REACT_PREFIX + "forward_ref)";
var LAZY_SYMBOL_STRING = REACT_PREFIX + "lazy)";
var MEMO_SYMBOL_STRING = REACT_PREFIX + "memo)";
function useFiber() {
  try {
    const fiber = React.useRef();
    React.useState(() => {
      const bind = functionProto.bind;
      functionProto.bind = function(self, maybeFiber) {
        if (self === _null && typeof maybeFiber?.type === "function") {
          fiber.current = maybeFiber;
          functionProto.bind = bind;
        }
        return bind.apply(this, arguments);
      };
    });
    return fiber.current;
  } catch (e) {
    return _null;
  }
}
var getTimings = (fiber) => {
  const totalTime = fiber?.actualDuration ?? 0;
  let selfTime = totalTime;
  let child = fiber?.child;
  while (totalTime > 0 && child != _null) {
    selfTime -= child?.actualDuration || 0;
    child = child.sibling;
  }
  return {
    /**
     * totalTime
     */
    t: totalTime,
    /**
     * selfTime
     */
    s: selfTime
  };
};
var getOwner = (fiber) => {
  let type = fiber?._debugOwner?.type;
  if (!type) {
    const owner = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner.current;
    type = owner?._debugOwner?.type;
  }
  if (!type || typeof type !== "function")
    return _null;
  return type[FLAG] || _null;
};
var truncateString = (value, length) => {
  return value.length > length ? value.slice(0, length) + "\u2026" : value;
};
var serialize = (value) => {
  switch (typeof value) {
    case "function":
      return truncateString(value.toString(), 20);
    case "string":
      return truncateString(value, 20);
    case "object":
      if (value === _null) {
        return "null";
      }
      if (_Array.isArray(value)) {
        return value.length > 0 ? "[\u2026]" : "[]";
      }
      if (typeof value.$$typeof === "symbol" && String(value.$$typeof) === ELEMENT_SYMBOL_STRING) {
        return "<" + (value.type.displayName || value.type.name || "") + (_Object.keys(value.props).length > 0 ? " \u2026" : "") + ">";
      }
      if (typeof value === "object" && value !== _null && value.constructor === _Object) {
        for (const key in value) {
          if (_objectHasOwnProperty.call(value, key)) {
            return "{\u2026}";
          }
        }
        return "{}";
      }
      const tagString = _objectToString.call(value).slice(8, -1);
      if (tagString === "Object") {
        const constructor = _Object.getPrototypeOf(value)?.constructor;
        if (typeof constructor === "function") {
          return (constructor.displayName || constructor.name || "") + "{\u2026}";
        }
      }
      return tagString + "{\u2026}";
    default:
      return String(value);
  }
};
var getFunctionFromJSX = (element) => {
  if (typeof element === "function") {
    return element;
  }
  if (typeof element !== "object") {
    return _null;
  }
  const type = element.type;
  if (typeof type === "function")
    return type;
  if (typeof type !== "object")
    return _null;
  if ("$$typeof" in type) {
    switch (String(type.$$typeof)) {
      case FORWARD_REF_SYMBOL_STRING:
        return getFunctionFromJSX(element.type.render);
      case MEMO_SYMBOL_STRING:
      case LAZY_SYMBOL_STRING:
        return getFunctionFromJSX(element.type);
    }
  }
  return _null;
};
var setRef = (ref, value) => {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref !== null && ref !== void 0) {
    ref.current = value;
  }
};
var mergeProps = (nextProps, prevProps) => {
  const overrideProps = _Object.assign({}, prevProps);
  for (const propName in prevProps) {
    const nextPropValue = nextProps[propName];
    const prevPropValue = prevProps[propName];
    if (propName.startsWith("on")) {
      if (nextPropValue && prevPropValue) {
        overrideProps[propName] = function() {
          prevPropValue.apply(this, arguments);
          nextPropValue.apply(this, arguments);
        };
      } else if (nextPropValue) {
        overrideProps[propName] = nextPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = Object.assign(prevPropValue, nextPropValue);
    } else if (propName === "className") {
      overrideProps[propName] = [nextPropValue, prevPropValue].filter(Boolean).join(" ");
    }
  }
  return _Object.assign(overrideProps, nextProps);
};

// runtime/src/core/utils/afterframe.ts
var callbacks = [];
var channel = new MessageChannel();
var postMessage = function() {
  this.postMessage(void 0);
}.bind(channel.port2);
channel.port1.onmessage = () => {
  const toFlush = callbacks;
  callbacks = [];
  for (let i = 0, len = toFlush.length; i < len; i++) {
    toFlush[i]();
  }
};
channel = null;
var afterFrame = (callback) => {
  if (callbacks.push(callback) === 1) {
    requestAnimationFrame(postMessage);
  }
};

// runtime/src/core/index.ts
var batchIndexLookup = new _Map();
var metadataLookup = new _Map();
var batch = [];
var inited = false;
var session = getSession();
var url = _null;
var apiKey;
var buildId;
var onRender = _null;
var getMetadata = (key) => {
  return _mapGet.call(metadataLookup, key);
};
var getChange = (prevValue, nextValue) => {
  if (_Object.is(prevValue, nextValue))
    return _null;
  const prev = serialize(prevValue);
  const next = serialize(nextValue);
  const type = nextValue ? typeof nextValue : typeof prevValue;
  const unstable = prev === next && ["object", "function"].includes(type);
  return {
    // unstable
    u: unstable,
    // type
    t: type,
    // count
    c: 1,
    // index: (if it's a change of the deps array, this will be the index of the dep)
    i: _null,
    // name: used to help identify the change
    // prop change postfixes this with the name of the prop
    n: prev === next ? prev : prev + next
  };
};
var captureClass = (key, data, setState, loc, index) => {
  return function() {
    const value = arguments[0];
    const fiber = useFiber();
    const owner = getOwner(fiber);
    const {
      s,
      t
      /* totalTime */
    } = getTimings(fiber);
    const prevValue = data.c[index];
    setState.apply(this, arguments);
    const change = getChange(prevValue, value);
    if (change) {
      reportRender(
        // key: encode(filename).encoded(componentName)
        // (e.g. "/some/file/path/index.jsx.App")
        key,
        4 /* Reducer */,
        // CaptureKind
        // loc: encode(SourceLocation)
        // e.g. `this.setState(newVal)` -> encode([1, 2, 3, 4])
        loc,
        _null,
        // secondaryLoc
        _null,
        // locs
        s,
        // selfTime
        t,
        // totalTime
        1,
        // count
        _null,
        // self
        owner,
        // owner
        _null,
        // error
        [change]
        // changes
      );
      data.c[data.i] = value;
    }
    return value;
  };
};
var captureDeps = (key, data, deps, loc, locs, index) => {
  if (!_isArray(deps))
    return deps;
  const prevDeps = data.c[index];
  const fiber = useFiber();
  const owner = getOwner(fiber);
  const {
    s,
    t
    /* totalTime */
  } = getTimings(fiber);
  if (prevDeps) {
    const changes = [];
    for (let i = 0, len = deps.length; i < len; i++) {
      const prevDepValue = prevDeps[i];
      const nextDepValue = deps[i];
      const change = getChange(prevDepValue, nextDepValue);
      if (!change)
        continue;
      changes.push(change);
    }
    if (changes.length) {
      reportRender(
        // key: encode(filename).encoded(componentName)
        // (e.g. "/some/file/path/index.jsx.App")
        key,
        1 /* Deps */,
        // CaptureKind
        // loc: encode(SourceLocation)
        // e.g. `[foo, bar, baz]` -> encode([1, 2, 3, 4])
        loc,
        _null,
        // secondaryLoc
        // locs: encode([Dep1SourceLocation, Dep2SourceLocation, ...])
        // e.g. `[foo, bar, baz]` -> encode([[1, 2, 3, 4], [5, 6, 7, 8], ...])
        locs,
        s,
        // selfTime
        t,
        // totalTime
        1,
        // count
        _null,
        // self
        owner,
        // owner
        _null,
        // error
        changes
        // changes
      );
    }
  }
  data.c[index] = deps;
  return deps;
};
var captureValue = (key, data, value, loc, index) => {
  const owner = getOwner(_null);
  const prevValue = data.c[index];
  if (prevValue) {
    const change = getChange(prevValue, value);
    if (!change)
      return value;
    reportRender(
      // key: encode(filename).encoded(componentName)
      // e.g. "/some/file/path/index.jsx.App"
      key,
      // CaptureKind
      8 /* Value */,
      // loc: encode(SourceLocation)
      loc,
      // loc: encode(SourceLocation)
      _null,
      // secondaryLoc
      _null,
      // locs
      0,
      // selfTime
      0,
      // totalTime
      1,
      // count
      _null,
      // self
      owner,
      // owner
      _null,
      // error
      [change]
      // changes
    );
  }
  data.c[index] = value;
  return value;
};
var captureProps = (key, data, props, loc, index) => {
  if (typeof props !== "object")
    return props;
  const prevProps = data.c[index];
  const fiber = useFiber();
  const owner = getOwner(fiber);
  if (prevProps) {
    const changes = [];
    for (const name in props) {
      const prevPropValue = prevProps[name];
      const nextPropValue = props[name];
      const change = getChange(prevPropValue, nextPropValue);
      if (!change)
        continue;
      change.n = name;
      changes.push(change);
    }
    if (changes.length) {
      const {
        s,
        t
        /* totalTime */
      } = getTimings(fiber);
      reportRender(
        // key: encode(filename).encoded(componentName)
        // e.g. "/some/file/path/index.jsx.App"
        key,
        2 /* Props */,
        // CaptureKind
        loc,
        // loc: encode(SourceLocation)
        _null,
        // secondaryLoc
        _null,
        // locs
        s,
        // selfTime
        t,
        // totalTime
        1,
        // count
        _null,
        // self
        owner,
        // owner
        _null,
        // error
        changes
        // changes
      );
    }
  }
  data.c[index] = props;
  return props;
};
var captureReducer = (key, data, value, loc, index) => {
  if (!_isArray(value))
    return value;
  const fiber = useFiber();
  const owner = getOwner(fiber);
  const dispatcher = value[1];
  data.c[index] = value[0];
  value[1] = function(nextValue) {
    const prevValue = value[0];
    dispatcher(nextValue);
    const change = getChange(prevValue, nextValue);
    if (!change)
      return;
    const {
      s,
      t
      /* totalTime */
    } = getTimings(fiber);
    reportRender(
      // key: encode(filename).encoded(componentName)
      // e.g. "/some/file/path/index.jsx.App"
      key,
      4 /* Reducer */,
      // CaptureKind
      loc,
      // loc: encode(SourceLocation)
      _null,
      // secondaryLoc
      _null,
      // locs
      s,
      // selfTime
      t,
      // totalTime
      1,
      // count
      _null,
      // self
      owner,
      // owner
      _null,
      // error
      [change]
      // changes
    );
  };
  return value;
};
var captureFunction = (key, fn, loc) => {
  if (typeof fn !== "function")
    return fn;
  if (FLAG in fn)
    return fn;
  fn[FLAG] = true;
  return function() {
    const startTime = _performance.now();
    try {
      const ret = fn.apply(this, arguments);
      const endTime = _performance.now();
      afterFrame(() => {
        const selfTime = endTime - startTime;
        const totalTime = _performance.now() - startTime;
        reportRender(
          // key: encode(filename).encoded(componentName)
          // e.g. "/some/file/path/index.jsx.App"
          key,
          128 /* Function */,
          loc,
          // loc
          null,
          // secondaryLoc
          _null,
          // locs
          selfTime,
          // selfTime
          totalTime,
          // totalTime
          1,
          // count
          null,
          // self
          null,
          // owner
          null,
          // error
          []
          // changes
        );
      });
      return ret;
    } catch (error) {
      reportRender(
        // key: encode(filename).encoded(componentName)
        // e.g. "/some/file/path/index.jsx.App"
        key,
        256 /* Error */,
        loc,
        // loc
        null,
        // secondaryLoc
        _null,
        // locs
        0,
        // selfTime
        0,
        // totalTime
        1,
        // count
        null,
        // self
        null,
        // owner
        error.message.split("\n")[0],
        // error
        []
        // changes
      );
      throw error;
    }
  };
};
var Profiler = class extends React2.Component {
  constructor(props) {
    super(props);
    this.m = _performance.now();
  }
  componentDidMount() {
    const mountTime = this.m;
    if (mountTime) {
      const selfTime = _performance.now() - mountTime;
      afterFrame(() => {
        this.props._r?.(
          64 /* JSXUpdate */,
          selfTime,
          _performance.now() - mountTime
        );
      });
      this.m = void 0;
    }
  }
  shouldComponentUpdate() {
    if (this.m) {
      this.u = _performance.now();
    }
    return true;
  }
  componentDidUpdate() {
    const updateTime = this.u;
    if (updateTime) {
      const selfTime = _performance.now() - updateTime;
      afterFrame(() => {
        this.props._r?.(
          64 /* JSXUpdate */,
          selfTime,
          _performance.now() - updateTime
        );
      });
      this.u = void 0;
    }
  }
  componentWillUnmount() {
    const unmountTime = _performance.now();
    afterFrame(() => {
      const time = _performance.now() - unmountTime;
      this.props._r?.(64 /* JSXUpdate */, time, time);
    });
  }
  render() {
    return this.props.children;
  }
};
var AnyaProfiler = React2.forwardRef((props, forwardedRef) => {
  const element = props._l;
  const originalRef = element.ref;
  if (React2.isValidElement(element)) {
    let ref = originalRef;
    if (forwardedRef) {
      ref = (value) => {
        setRef(originalRef, value);
        setRef(forwardedRef, value);
      };
    }
    const newProps = _Object.assign(mergeProps(element.props, props), {
      ref
    });
    newProps._r = void 0;
    newProps._l = void 0;
    return React2.createElement(Profiler, {
      key: element.key,
      _r: props._r,
      children: React2.cloneElement(element, newProps)
    });
  }
  return props.children;
});
var captureJSX = (key, data, element, loc, secondaryLoc, index) => {
  const owner = getOwner(null);
  const reference = getFunctionFromJSX(element);
  const self = reference?.[FLAG];
  return React2.createElement(AnyaProfiler, {
    _l: element,
    // assume children is a JSX element!
    key: element.key || void 0,
    _r: (kind, selfTime, totalTime) => {
      const changes = [];
      const prevValue = data.c[index];
      if (prevValue) {
        const change = getChange(prevValue, reference);
        if (!change)
          return;
        changes.push(change);
      }
      reportRender(
        // key: encode(filename).encoded(componentName)
        // e.g. "/some/file/path/index.jsx.App"
        key,
        // JSXMount = 'mount'
        // JSXUpdate = 'update' | 'nested-update' | 'unmount'
        kind,
        // loc = scoped source location of the JSX element,
        // or the location of the JSX element
        loc,
        secondaryLoc,
        // secondaryLoc = location of the JSX element
        _null,
        // locs
        selfTime,
        // selfTime
        totalTime,
        // totalTime
        1,
        // count
        self,
        // self
        owner,
        // owner
        _null,
        // error
        changes
        // changes
      );
      data.c[data.i] = reference;
    }
  });
};
var captureMount = (data) => {
  React2.useEffect(() => {
    if (!data)
      return;
    data.i++;
    return () => {
      data.i--;
    };
  }, []);
};
var capture = (kind, key, value, loc, secondaryLoc, locs, index) => {
  if (isSSR)
    return;
  const data = getMetadata(key);
  if (!data)
    return value;
  if (kind & 512 /* ComponentMount */) {
    return captureMount(data);
  } else if (kind & 2 /* Props */) {
    return captureProps(key, data, value, loc, index);
  } else if (kind & 4 /* Reducer */) {
    return captureReducer(key, data, value, loc, index);
  } else if (kind & 1 /* Deps */) {
    return captureDeps(key, data, value, loc, locs, index);
  } else if (kind & 16 /* JSX */) {
    return captureJSX(key, data, value, loc, secondaryLoc, index);
  } else if (kind & 8 /* Value */) {
    return captureValue(key, data, value, loc, index);
  } else if (kind & 128 /* Function */) {
    return captureFunction(key, value, loc);
  } else if (kind & 0 /* ClassSetState */) {
    return captureClass(key, data, value, loc, index);
  }
  return value;
};
var mergeChange = (prev, next) => {
  if (!prev && !next)
    return [];
  if (!prev?.length)
    return next;
  if (!next?.length)
    return prev;
  let prevHead = 0;
  let nextHead = 0;
  let prevTail = prev.length - 1;
  let nextTail = next.length - 1;
  while (prevHead < prevTail && nextHead < nextTail) {
    const prevHeadChange = prev[prevHead];
    const nextHeadChange = next[nextHead];
    const prevTailChange = prev[prevTail - 1];
    const nextTailChange = next[nextTail - 1];
    if (prevHeadChange.n === nextHeadChange.n) {
      prevHeadChange.c += nextHeadChange.c;
      if (!prevHeadChange.u) {
        prevHeadChange.u = nextHeadChange.u;
      }
      prevHead++;
      nextHead++;
    } else if (prevTailChange.n === nextTailChange.n) {
      prevTailChange.c += nextTailChange.c;
      if (!prevTailChange.u) {
        prevTailChange.u = nextTailChange.u;
      }
      prevTail--;
      nextTail--;
    } else {
      break;
    }
  }
  const changeIndexLookup = new _Map();
  for (; prevHead < prevTail; prevHead++) {
    _mapSet.call(changeIndexLookup, prev[prevHead].n, prevHead);
  }
  for (; nextHead < nextTail; nextHead++) {
    const nextProp = next[nextHead];
    const prevPropIndex = _mapGet.call(changeIndexLookup, nextProp.n);
    if (prevPropIndex === void 0) {
      const index = prev.push(nextProp);
      _mapSet.call(changeIndexLookup, nextProp.n, index);
      continue;
    }
    const prevProp = prev[prevPropIndex];
    prevProp.c++;
    if (!prevProp.u) {
      prevProp.u = nextProp.u;
    }
  }
  return prev;
};
var reportRender = (key, kind, loc, secondaryLoc, locs, selfTime, totalTime, count, self, owner, error, changes) => {
  const render = {
    k: kind,
    l: loc,
    l2: secondaryLoc,
    ls: locs,
    s: selfTime,
    t: totalTime,
    c: count,
    i: self,
    o: owner,
    e: error,
    d: changes
  };
  const batchKey = getRenderBatchIndexKey(key, kind, loc, owner, error);
  if (_mapHas.call(batchIndexLookup, batchKey)) {
    const prevIndex = _mapGet.call(batchIndexLookup, batchKey);
    const prevRender = batch[prevIndex].r;
    prevRender.c++;
    prevRender.t += render.t;
    prevRender.s += render.s;
    prevRender.d = mergeChange(prevRender.d, render.d);
    return;
  }
  _mapSet.call(batchIndexLookup, batchKey, batch.length);
  const renderItem = {
    k: key,
    r: render
  };
  if (batch.length >= MAX_QUEUE_SIZE) {
    flush();
    return;
  }
  batch.push(renderItem);
  onRender?.();
};
var flush = () => {
  const renderItems = batch.length;
  if (!url || !navigator.onLine || !renderItems || !apiKey)
    return;
  try {
    const components = _Object.create(_null);
    metadataLookup.forEach((value, key) => {
      components[key] = value.i;
    });
    const payload = {
      batch,
      components,
      session,
      buildId,
      apiKey,
      version: VERSION,
      react: React2.version || UNKNOWN,
      geo: void 0
    };
    void transport(url, payload).then(() => {
      if (true) {
        console.log(`[Million Lint] Ingested ${renderItems} events`);
      }
    }).catch(() => {
    });
  } catch (_err) {
  }
  reset();
};
var reset = () => {
  batch.length = 0;
  batchIndexLookup.clear();
};
var registerMetadata = (key, size, reference) => {
  if (isSSR)
    return;
  if (_mapHas.call(metadataLookup, key))
    return;
  if (reference && !(FLAG in reference)) {
    reference[FLAG] = key;
  }
  const cache = size ? new _Array(size) : _null;
  _mapSet.call(metadataLookup, key, {
    r: reference,
    c: cache,
    i: 0
  });
};
var init = (options) => {
  if (isSSR)
    return;
  _window[FLAG] = true;
  url = options?.url || url || ENDPOINT;
  buildId ||= options?.id;
  apiKey = options?.apiKey;
  if (inited)
    return;
  inited = true;
  if (true) {
    console.log(`[Million Lint] Initialized with ${url}`);
  }
  const lazyFlush = () => onIdle(flush);
  onHidden(lazyFlush);
  const debouncedLazyFlush = debounce(lazyFlush, FLUSH_TIMEOUT);
  const checkExpiry = debounce(() => {
    session = getSession();
  }, SESSION_EXPIRE_TIMEOUT);
  onRender = () => {
    debouncedLazyFlush();
    checkExpiry();
  };
};
if (true) {
  (() => {
    if (isSSR)
      return;
    window[`${FLAG}DEV_`] = {
      batch,
      flush,
      reset
    };
  })();
}
export {
  capture,
  init,
  registerMetadata,
  reset
};
